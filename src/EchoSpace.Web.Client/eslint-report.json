[{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\app.component.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\app.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\app.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\app.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\auth-callback\\auth-callback.component.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\auth-callback\\auth-callback.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\confirmation-modal\\confirmation-modal.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\dashboard\\dashboard.component.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\dashboard\\dashboard.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\email-verification\\email-verification.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\forgot-password\\forgot-password.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\home\\home.component.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":363,"column":29,"nodeType":"MemberExpression","endLine":363,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":367,"column":7,"nodeType":"MemberExpression","endLine":367,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":406,"column":22,"nodeType":"MemberExpression","endLine":406,"endColumn":52},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":435,"column":7,"nodeType":"MemberExpression","endLine":435,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":466,"column":5,"nodeType":"MemberExpression","endLine":466,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":466,"column":42,"nodeType":"MemberExpression","endLine":466,"endColumn":75},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":470,"column":5,"nodeType":"MemberExpression","endLine":470,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":475,"column":7,"nodeType":"MemberExpression","endLine":475,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":490,"column":9,"nodeType":"MemberExpression","endLine":490,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":504,"column":7,"nodeType":"MemberExpression","endLine":504,"endColumn":40},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":515,"column":5,"nodeType":"MemberExpression","endLine":515,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":516,"column":5,"nodeType":"MemberExpression","endLine":516,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":523,"column":9,"nodeType":"MemberExpression","endLine":523,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":528,"column":9,"nodeType":"MemberExpression","endLine":528,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":540,"column":9,"nodeType":"MemberExpression","endLine":540,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":562,"column":5,"nodeType":"MemberExpression","endLine":562,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":568,"column":9,"nodeType":"MemberExpression","endLine":568,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":573,"column":9,"nodeType":"MemberExpression","endLine":573,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":774,"column":5,"nodeType":"MemberExpression","endLine":774,"endColumn":31},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":774,"column":35,"nodeType":"MemberExpression","endLine":774,"endColumn":61},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":778,"column":12,"nodeType":"MemberExpression","endLine":778,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":817,"column":11,"nodeType":"MemberExpression","endLine":817,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":947,"column":5,"nodeType":"MemberExpression","endLine":947,"endColumn":30},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":947,"column":34,"nodeType":"MemberExpression","endLine":947,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, OnInit, HostListener } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { Router, RouterModule } from '@angular/router';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { AuthService } from '../../services/auth.service';\r\nimport { PostsService } from '../../services/posts.service';\r\nimport { FollowsService } from '../../services/follows.service';\r\nimport { LikesService } from '../../services/likes.service';\r\nimport { TagsService } from '../../services/tags.service';\r\nimport { NavbarDropdownComponent } from '../navbar-dropdown/navbar-dropdown.component';\r\nimport { SearchBarComponent } from '../search-bar/search-bar.component';\r\nimport { SuggestedUsersComponent } from '../suggested-users/suggested-users.component';\r\nimport { PostDropdownComponent } from '../post-dropdown/post-dropdown.component';\r\nimport { ConfirmationModalComponent } from '../confirmation-modal/confirmation-modal.component';\r\nimport { ToastService } from '../../services/toast.service';\r\nimport { Post, CreatePostRequest, UpdatePostRequest } from '../../interfaces';\r\nimport { TrendingTag } from '../../services/tags.service';\r\nimport { User } from '../../services/user.service';\r\nimport { PostCommentsComponent } from '../post-comments/post-comments.component';\r\nimport { UserService } from '../../services/user.service';\r\nimport { ProfileCardComponent } from '../profile-card/profile-card.component';\r\nimport { environment } from '../../../environments/environment';\r\nimport { normalizeRole } from '../../utils/role.util';\r\n\r\n@Component({\r\n  selector: 'app-home',\r\n  standalone: true,\r\n  imports: [CommonModule, RouterModule, FormsModule, NavbarDropdownComponent, SearchBarComponent, SuggestedUsersComponent, PostDropdownComponent, ConfirmationModalComponent, PostCommentsComponent, ProfileCardComponent],\r\n  templateUrl: './home.component.html',\r\n  styleUrl: './home.component.css'\r\n})\r\nexport class HomeComponent implements OnInit {\r\n  isLoading = false;\r\n  isCreatingPost = false;\r\n  posts: Post[] = []; // Remove mock data\r\n  \r\n  // Create post form\r\n  newPost = {\r\n    content: '',\r\n    imageUrl: '',\r\n    tagIds: [] as string[],\r\n    generateImage: false\r\n  };\r\n  \r\n  // Tags\r\n  tags: TrendingTag[] = [];\r\n  isLoadingTags = false;\r\n  showTagSelector = false;\r\n\r\n  // Photo upload\r\n  selectedFile: File | null = null;\r\n  imagePreview: string | null = null;\r\n  \r\n  // Post editing\r\n  editingPost: Post | null = null;\r\n  editPostForm = {\r\n    content: '',\r\n    imageUrl: ''\r\n  };\r\n  isEditingPost = false;\r\n  isSavingPost = false;\r\n  isDeletingPost = false;\r\n  \r\n  // Dropdown states\r\n  openDropdowns: { [postId: string]: boolean } = {};\r\n  \r\n  // Confirmation modal\r\n  showDeleteModal = false;\r\n  postToDelete: Post | null = null;\r\n  \r\n  showComments: { [postId: string]: boolean } = {};\r\n\r\n  // Translation states\r\n  translatingPosts: { [postId: string]: boolean } = {};\r\n  translationLanguage: string = 'en'; // Default to English\r\n  showLanguageSelector: { [postId: string]: boolean } = {};\r\n  \r\n  // Summarization state\r\n  summarizingPosts: { [postId: string]: boolean } = {};\r\n  \r\n  // Available languages for translation\r\n  availableLanguages = [\r\n    { code: 'en', name: 'English' },\r\n    { code: 'ar', name: 'Arabic' },\r\n    { code: 'fr', name: 'French' },\r\n    { code: 'es', name: 'Spanish' },\r\n    { code: 'de', name: 'German' },\r\n    { code: 'it', name: 'Italian' },\r\n    { code: 'pt', name: 'Portuguese' },\r\n    { code: 'ru', name: 'Russian' },\r\n    { code: 'zh', name: 'Chinese' },\r\n    { code: 'ja', name: 'Japanese' },\r\n    { code: 'ko', name: 'Korean' },\r\n    { code: 'hi', name: 'Hindi' },\r\n    { code: 'tr', name: 'Turkish' },\r\n    { code: 'nl', name: 'Dutch' },\r\n    { code: 'pl', name: 'Polish' }\r\n  ];\r\n\r\n  currentUser = {\r\n    name: 'John Doe',\r\n    email: 'john.doe@example.com',\r\n    initials: 'JD',\r\n    role: 'User',\r\n    id: '',\r\n    profilePhotoUrl: null as string | null\r\n  };\r\n\r\n  // User statistics\r\n  userStats = {\r\n    postsCount: 0,\r\n    followersCount: 0,\r\n    followingCount: 0\r\n  };\r\n  isLoadingStats = false;\r\n\r\n  feedType: 'all' | 'following' = 'following';\r\n\r\n  // Cache for profile photos by user ID\r\n  profilePhotoCache: { [userId: string]: string } = {};\r\n\r\n  constructor(\r\n    private router: Router,\r\n    private authService: AuthService,\r\n    private postsService: PostsService,\r\n    private followsService: FollowsService,\r\n    private likesService: LikesService,\r\n    private toastService: ToastService,\r\n    private userService: UserService,\r\n    private tagsService: TagsService\r\n  ) {}\r\n  \r\n\r\n\r\n  trendingTags: TrendingTag[] = [];\r\n  isLoadingTrendingTags = false;\r\n\r\n  ngOnInit(): void {\r\n    // Load current user data\r\n    this.loadUserData();\r\n    \r\n    // Load tags\r\n    this.loadTags();\r\n    \r\n    // Load trending tags\r\n    this.loadTrendingTags();\r\n    \r\n    // Load posts\r\n    this.loadPosts();\r\n  }\r\n\r\n  loadUserData(): void {\r\n    // Subscribe to current user from auth service\r\n    this.authService.currentUser$.subscribe(user => {\r\n      if (user) {\r\n        this.currentUser = {\r\n          name: user.username || user.name || 'User',\r\n          email: user.email || '',\r\n          initials: this.getInitials(user.username || user.name || user.email || 'U'),\r\n          role: user.role || 'User',\r\n          id: user.id || '',\r\n          profilePhotoUrl: null\r\n        };\r\n        \r\n        // Redirect Operation users to their homepage\r\n        const normalizedRole = normalizeRole(this.currentUser.role);\r\n        if (normalizedRole === 'Operation') {\r\n          this.router.navigate(['/operation']);\r\n          return;\r\n        }\r\n        \r\n        // Load user statistics once we have the user ID\r\n        if (this.currentUser.id) {\r\n          this.loadUserStatistics();\r\n          this.loadUserProfile();\r\n        }\r\n      } else {\r\n        // User data should be loaded from authService.currentUser$\r\n        // The interceptor will handle token automatically\r\n        // If no user is loaded, redirect to login\r\n        this.router.navigate(['/login']);\r\n        return;\r\n      }\r\n    });\r\n  }\r\n\r\n  loadUserProfile(): void {\r\n    if (!this.currentUser.id) {\r\n      console.log('loadUserProfile: No user ID available');\r\n      return;\r\n    }\r\n    \r\n    console.log('loadUserProfile: Loading user profile for ID:', this.currentUser.id);\r\n    \r\n    this.userService.getCurrentUser().subscribe({\r\n      next: (user: User) => {\r\n        console.log('loadUserProfile: Received user data:', user);\r\n        \r\n        // Update user info if needed\r\n        if (user.name) {\r\n          this.currentUser.name = user.name;\r\n          this.currentUser.initials = this.getInitials(user.name);\r\n        }\r\n        if (user.email) {\r\n          this.currentUser.email = user.email;\r\n        }\r\n        \r\n        // Handle both camelCase and PascalCase property names\r\n        const profilePhotoId = user.profilePhotoId;\r\n        \r\n        console.log('loadUserProfile: Profile photo ID:', profilePhotoId);\r\n        \r\n        // Load profile photo if exists\r\n        if (profilePhotoId) {\r\n          console.log('loadUserProfile: Loading profile photo URL for imageId:', profilePhotoId);\r\n          this.loadProfilePhotoUrl(profilePhotoId);\r\n        } else {\r\n          console.log('loadUserProfile: No profile photo ID found');\r\n          // Clear profile photo if none exists\r\n          this.currentUser.profilePhotoUrl = null;\r\n          if (this.currentUser.id) {\r\n            delete this.profilePhotoCache[this.currentUser.id];\r\n          }\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading user profile:', error);\r\n        console.error('Error details:', JSON.stringify(error, null, 2));\r\n      }\r\n    });\r\n  }\r\n\r\n  loadProfilePhotoUrl(imageId: string): void {\r\n    if (!imageId) {\r\n      console.warn('loadProfilePhotoUrl: No imageId provided');\r\n      return;\r\n    }\r\n    \r\n    console.log('loadProfilePhotoUrl: Loading URL for imageId:', imageId);\r\n    // environment.apiUrl already includes /api, so we don't need to add it again\r\n    const url = `${environment.apiUrl}/images/${imageId}/url`;\r\n    console.log('loadProfilePhotoUrl: Fetching from:', url);\r\n    \r\n    fetch(url, {\r\n      headers: {\r\n        'Authorization': `Bearer ${this.authService.getToken()}`\r\n      }\r\n    })\r\n    .then(response => {\r\n      console.log('loadProfilePhotoUrl: Response status:', response.status);\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      return response.json();\r\n    })\r\n    .then(data => {\r\n      console.log('loadProfilePhotoUrl: Received data:', data);\r\n      if (data && data.url) {\r\n        // Only update if we got a valid URL\r\n        console.log('loadProfilePhotoUrl: Setting profile photo URL:', data.url);\r\n        this.currentUser.profilePhotoUrl = data.url;\r\n        \r\n        // Update cache for current user\r\n        if (this.currentUser.id) {\r\n          this.profilePhotoCache[this.currentUser.id] = data.url;\r\n          console.log('loadProfilePhotoUrl: Updated cache for user:', this.currentUser.id);\r\n        }\r\n        \r\n        // Update all posts by current user\r\n        this.posts.forEach(post => {\r\n          if (post.author?.userId === this.currentUser.id) {\r\n            if (post.author) {\r\n              post.author.profilePhotoUrl = data.url;\r\n            }\r\n          }\r\n        });\r\n        console.log('loadProfilePhotoUrl: Updated', this.posts.filter(p => p.author?.userId === this.currentUser.id).length, 'posts with new profile photo');\r\n      } else {\r\n        console.warn('loadProfilePhotoUrl: Response did not contain a valid URL:', data);\r\n      }\r\n    })\r\n    .catch(error => {\r\n      console.error('loadProfilePhotoUrl: Error loading profile photo URL:', error);\r\n      console.error('loadProfilePhotoUrl: Error details:', error.message);\r\n      // Don't clear the existing URL on error - keep what we have\r\n    });\r\n  }\r\n\r\n  onProfilePhotoUpdated(imageUrl: string): void {\r\n    // Handle profile photo update from profile card component\r\n    console.log('onProfilePhotoUpdated: Profile photo updated:', imageUrl);\r\n    \r\n    // Update cache for current user\r\n    if (this.currentUser.id) {\r\n      this.profilePhotoCache[this.currentUser.id] = imageUrl;\r\n    }\r\n    \r\n    // Update all posts by current user to show new profile photo\r\n    this.posts.forEach(post => {\r\n      if (post.author?.userId === this.currentUser.id) {\r\n        if (post.author) {\r\n          post.author.profilePhotoUrl = imageUrl;\r\n        }\r\n      }\r\n    });\r\n    console.log('onProfilePhotoUpdated: Updated posts count:', this.posts.filter(p => p.author?.userId === this.currentUser.id).length);\r\n  }\r\n\r\n  getInitials(name: string): string {\r\n    if (!name) return 'U';\r\n    \r\n    // If it's an email, use first letter\r\n    if (name.includes('@')) {\r\n      return name.charAt(0).toUpperCase();\r\n    }\r\n    \r\n    // Split by space and get first letter of each word\r\n    const words = name.trim().split(' ');\r\n    if (words.length === 1) {\r\n      return words[0].substring(0, 2).toUpperCase();\r\n    }\r\n    \r\n    return (words[0].charAt(0) + words[words.length - 1].charAt(0)).toUpperCase();\r\n  }\r\n\r\n  loadPosts(): void {\r\n    this.isLoading = true;\r\n    \r\n    const postsObservable = this.feedType === 'following' \r\n      ? this.postsService.getPostsFromFollowing()\r\n      : this.postsService.getRecentPosts(20);\r\n\r\n    postsObservable.subscribe({\r\n      next: (posts) => {\r\n        this.posts = posts.map(post => this.transformPostForDisplay(post));\r\n        // Load profile photos for all post authors\r\n        this.loadProfilePhotosForPosts(this.posts);\r\n        this.isLoading = false;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading posts:', error);\r\n        this.isLoading = false;\r\n        // Fallback to empty array or show error message\r\n        this.posts = [];\r\n        if (this.feedType === 'following') {\r\n          this.toastService.info('No Posts', 'No posts from followed users yet');\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  switchFeed(type: 'all' | 'following'): void {\r\n    this.feedType = type;\r\n    this.loadPosts();\r\n  }\r\n\r\n  private transformPostForDisplay(apiPost: Partial<Post> & { userId: string; createdAt: string }): Post {\r\n    // Use backend author information if available, otherwise fallback to current user\r\n    const authorName = apiPost.authorName || apiPost.author?.name || 'Unknown User';\r\n    const userId = apiPost.userId;\r\n    \r\n    // Check if we already have profile photo in cache\r\n    const profilePhotoUrl = this.profilePhotoCache[userId] || null;\r\n    \r\n    // If it's the current user, use their profile photo\r\n    if (userId === this.currentUser.id && this.currentUser.profilePhotoUrl) {\r\n      this.profilePhotoCache[userId] = this.currentUser.profilePhotoUrl;\r\n    }\r\n    \r\n    return {\r\n      ...apiPost,\r\n      timeAgo: this.calculateTimeAgo(apiPost.createdAt),\r\n      author: {\r\n        name: authorName,\r\n        initials: this.getInitials(authorName),\r\n        userId: userId,\r\n        profilePhotoUrl: profilePhotoUrl || (userId === this.currentUser.id ? this.currentUser.profilePhotoUrl : null)\r\n      },\r\n      authorProfilePhotoId: apiPost.authorProfilePhotoId\r\n    };\r\n  }\r\n\r\n  private transformNewPostForDisplay(apiPost: Partial<Post> & { userId?: string; createdAt: string }): Post {\r\n    // For newly created posts, use current user info if author info is not available\r\n    const authorName = apiPost.authorName || apiPost.author?.name || this.currentUser.name || 'Unknown User';\r\n    const userId = apiPost.userId || this.currentUser.id || '';\r\n    \r\n    return {\r\n      ...apiPost,\r\n      timeAgo: this.calculateTimeAgo(apiPost.createdAt),\r\n      author: {\r\n        name: authorName,\r\n        initials: this.getInitials(authorName),\r\n        userId: userId,\r\n        profilePhotoUrl: userId === this.currentUser.id ? this.currentUser.profilePhotoUrl : null\r\n      }\r\n    };\r\n  }\r\n\r\n  private loadProfilePhotosForPosts(posts: Post[]): void {\r\n    // Get unique user IDs from posts\r\n    const userIds = [...new Set(posts.map(post => post.author?.userId).filter(id => id && id !== this.currentUser.id))];\r\n    \r\n    // Load profile photos for each unique user\r\n    userIds.forEach(userId => {\r\n      if (userId && !this.profilePhotoCache[userId]) {\r\n        this.loadAuthorProfilePhoto(userId);\r\n      }\r\n    });\r\n  }\r\n\r\n  private loadAuthorProfilePhoto(userId: string): void {\r\n    this.userService.getUserById(userId).subscribe({\r\n      next: (user: User) => {\r\n        if (user.profilePhotoId) {\r\n          this.loadProfilePhotoUrlForAuthor(userId, user.profilePhotoId);\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error(`Error loading user ${userId}:`, error);\r\n      }\r\n    });\r\n  }\r\n\r\n  private loadProfilePhotoUrlForAuthor(userId: string, imageId: string): void {\r\n    // environment.apiUrl already includes /api, so we don't need to add it again\r\n    fetch(`${environment.apiUrl}/images/${imageId}/url`, {\r\n      headers: {\r\n        'Authorization': `Bearer ${this.authService.getToken()}`\r\n      }\r\n    })\r\n    .then(response => response.json())\r\n    .then(data => {\r\n      // Cache the profile photo URL\r\n      this.profilePhotoCache[userId] = data.url;\r\n      \r\n      // Update all posts with this author's profile photo\r\n      this.posts.forEach(post => {\r\n        if (post.author?.userId === userId) {\r\n          if (post.author) {\r\n            post.author.profilePhotoUrl = data.url;\r\n          }\r\n        }\r\n      });\r\n    })\r\n    .catch(error => {\r\n      console.error(`Error loading profile photo URL for user ${userId}:`, error);\r\n    });\r\n  }\r\n\r\n  private calculateTimeAgo(createdAt: string): string {\r\n    const now = new Date();\r\n    const postDate = new Date(createdAt);\r\n    const diffInSeconds = Math.floor((now.getTime() - postDate.getTime()) / 1000);\r\n\r\n    if (diffInSeconds < 60) return 'Just now';\r\n    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;\r\n    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;\r\n    return `${Math.floor(diffInSeconds / 86400)}d ago`;\r\n  }\r\n\r\n  toggleLanguageSelector(postId: string, event?: Event): void {\r\n    if (event) {\r\n      event.stopPropagation();\r\n    }\r\n    this.showLanguageSelector[postId] = !this.showLanguageSelector[postId];\r\n  }\r\n\r\n  closeLanguageSelector(postId: string): void {\r\n    this.showLanguageSelector[postId] = false;\r\n  }\r\n\r\n  closeAllLanguageSelectors(): void {\r\n    Object.keys(this.showLanguageSelector).forEach(key => {\r\n      this.showLanguageSelector[key] = false;\r\n    });\r\n  }\r\n\r\n  @HostListener('document:click', ['$event'])\r\n  onDocumentClick(event: Event): void {\r\n    // Close language selectors when clicking outside\r\n    const target = event.target as HTMLElement;\r\n    const isLanguageSelector = target.closest('.language-selector-container');\r\n    if (!isLanguageSelector) {\r\n      this.closeAllLanguageSelectors();\r\n    }\r\n  }\r\n\r\n  translatePost(postId: string, language?: string): void {\r\n    if (this.translatingPosts[postId]) {\r\n      return; // Already translating\r\n    }\r\n\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (!post) {\r\n      return;\r\n    }\r\n\r\n    // If already translated, show original\r\n    if (post.isTranslated && post.translatedContent && !language) {\r\n      post.isTranslated = false;\r\n      post.translatedContent = undefined;\r\n      post.translationLanguage = undefined;\r\n      this.showLanguageSelector[postId] = false;\r\n      // Also clear summarization state if it was set\r\n      if (post.isSummarized) {\r\n        post.isSummarized = false;\r\n        post.summarizedContent = undefined;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Use provided language or default\r\n    const targetLanguage = language || this.translationLanguage;\r\n    this.showLanguageSelector[postId] = false;\r\n    this.translatingPosts[postId] = true;\r\n\r\n    this.postsService.translatePost(postId, targetLanguage).subscribe({\r\n      next: (response) => {\r\n        post.translatedContent = response.translated;\r\n        post.isTranslated = true;\r\n        post.translationLanguage = response.language;\r\n        this.translatingPosts[postId] = false;\r\n        this.toastService.success('Translated', `Post has been translated to ${this.getLanguageName(response.language)}.`);\r\n      },\r\n      error: (error) => {\r\n        console.error('Error translating post:', error);\r\n        this.translatingPosts[postId] = false;\r\n        this.toastService.error('Translation Failed', 'Failed to translate post. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  getLanguageName(code: string): string {\r\n    const lang = this.availableLanguages.find(l => l.code === code);\r\n    return lang ? lang.name : code.toUpperCase();\r\n  }\r\n\r\n  summarizePost(postId: string): void {\r\n    if (this.summarizingPosts[postId]) {\r\n      return; // Already summarizing\r\n    }\r\n\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (!post) {\r\n      return;\r\n    }\r\n\r\n    // If already summarized, show original\r\n    if (post.isSummarized && post.summarizedContent) {\r\n      post.isSummarized = false;\r\n      post.summarizedContent = undefined;\r\n      // Also clear translation state if it was set\r\n      if (post.isTranslated) {\r\n        post.isTranslated = false;\r\n        post.translatedContent = undefined;\r\n        post.translationLanguage = undefined;\r\n      }\r\n      return;\r\n    }\r\n\r\n    this.summarizingPosts[postId] = true;\r\n\r\n    this.postsService.summarizePost(postId).subscribe({\r\n      next: (response) => {\r\n        post.summarizedContent = response.summary;\r\n        post.isSummarized = true;\r\n        this.summarizingPosts[postId] = false;\r\n        this.toastService.success('Summarized', 'Post has been summarized successfully.');\r\n      },\r\n      error: (error) => {\r\n        console.error('Error summarizing post:', error);\r\n        this.summarizingPosts[postId] = false;\r\n        this.toastService.error('Summarization Failed', 'Failed to summarize post. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  likePost(postId: string): void {\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (!post) {\r\n      return;\r\n    }\r\n\r\n    // Optimistic update\r\n    const wasLiked = post.isLikedByCurrentUser;\r\n    post.isLikedByCurrentUser = !wasLiked;\r\n    post.likesCount += post.isLikedByCurrentUser ? 1 : -1;\r\n\r\n    // Call API to toggle like\r\n    this.likesService.toggleLike(postId).subscribe({\r\n      next: (response) => {\r\n        // Update with actual server response\r\n        post.isLikedByCurrentUser = response.isLiked ?? post.isLikedByCurrentUser;\r\n        post.likesCount = response.likesCount;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error toggling like:', error);\r\n        // Revert optimistic update on error\r\n        post.isLikedByCurrentUser = wasLiked;\r\n        post.likesCount += post.isLikedByCurrentUser ? 1 : -1;\r\n        this.toastService.error('Error', 'Failed to update like. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  createPost(): void {\r\n    if (!this.newPost.content.trim()) {\r\n      alert('Please enter some content for your post');\r\n      return;\r\n    }\r\n\r\n    if (!this.currentUser.id) {\r\n      alert('User not authenticated. Please log in again.');\r\n      return;\r\n    }\r\n\r\n    this.isCreatingPost = true;\r\n\r\n    // Determine image URL - use preview if file selected, otherwise use manual URL\r\n    const imageUrl = (this.imagePreview && this.selectedFile) \r\n      ? this.imagePreview  // Use data URL for now\r\n      : (this.newPost.imageUrl.trim() || undefined);\r\n\r\n    const createPostRequest: CreatePostRequest = {\r\n      userId: this.currentUser.id,\r\n      content: this.newPost.content.trim(),\r\n      imageUrl: imageUrl || \"\",\r\n      tagIds: this.newPost.tagIds.length > 0 ? this.newPost.tagIds : undefined,\r\n      generateImage: this.newPost.generateImage\r\n    };\r\n\r\n    this.postsService.createPost(createPostRequest).subscribe({\r\n      next: (newPost) => {\r\n        // For newly created posts, use current user info if author info is not available\r\n        const transformedPost = this.transformNewPostForDisplay(newPost);\r\n        // Add to the beginning of the posts array\r\n        this.posts.unshift(transformedPost);\r\n        \r\n        // Reset form\r\n        this.clearForm();\r\n        \r\n        this.isCreatingPost = false;\r\n        this.toastService.success('Success!', 'Your post has been created successfully.');\r\n        console.log('Post created successfully:', newPost);\r\n        \r\n        // Update user statistics (posts count)\r\n        this.loadUserStatistics();\r\n      },\r\n      error: (error) => {\r\n        console.error('Error creating post:', error);\r\n        this.isCreatingPost = false;\r\n        this.toastService.error('Error', 'Failed to create post. Post contains unsafe or toxic contents. Please fix post contents and try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  onImageUrlChange(event: Event): void {\r\n    const target = event.target as HTMLInputElement;\r\n    this.newPost.imageUrl = target.value;\r\n  }\r\n\r\n  clearForm(): void {\r\n    this.newPost = {\r\n      content: '',\r\n      imageUrl: '',\r\n      tagIds: [],\r\n      generateImage: false\r\n    };\r\n    this.selectedFile = null;\r\n    this.imagePreview = null;\r\n  }\r\n  \r\n  toggleTagSelection(tagId: string): void {\r\n    const index = this.newPost.tagIds.indexOf(tagId);\r\n    if (index > -1) {\r\n      this.newPost.tagIds.splice(index, 1);\r\n    } else {\r\n      this.newPost.tagIds.push(tagId);\r\n    }\r\n  }\r\n  \r\n  isTagSelected(tagId: string): boolean {\r\n    return this.newPost.tagIds.includes(tagId);\r\n  }\r\n  \r\n  loadTags(): void {\r\n    this.isLoadingTags = true;\r\n    this.tagsService.getAllTags().subscribe({\r\n      next: (tags) => {\r\n        this.tags = tags;\r\n        this.isLoadingTags = false;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading tags:', error);\r\n        this.isLoadingTags = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  loadTrendingTags(): void {\r\n    this.isLoadingTrendingTags = true;\r\n    this.tagsService.getTrendingTags(5).subscribe({\r\n      next: (tags) => {\r\n        this.trendingTags = tags;\r\n        this.isLoadingTrendingTags = false;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading trending tags:', error);\r\n        this.isLoadingTrendingTags = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  navigateToTag(tagId: string): void {\r\n    this.router.navigate(['/tag', tagId]);\r\n  }\r\n\r\n  formatPostCount(count: number): string {\r\n    if (count >= 1000) {\r\n      return (count / 1000).toFixed(1) + 'K';\r\n    }\r\n    return count.toString();\r\n  }\r\n\r\n  onPhotoClick(): void {\r\n    const fileInput = document.getElementById('photo-upload') as HTMLInputElement;\r\n    fileInput?.click();\r\n  }\r\n\r\n  onFileSelected(event: Event): void {\r\n    const target = event.target as HTMLInputElement;\r\n    const file = target.files?.[0];\r\n    \r\n    if (file) {\r\n      // Validate file type\r\n      if (!file.type.startsWith('image/')) {\r\n        alert('Please select an image file (JPG, PNG, GIF, etc.)');\r\n        return;\r\n      }\r\n\r\n      // Validate file size (5MB limit)\r\n      const maxSize = 5 * 1024 * 1024; // 5MB\r\n      if (file.size > maxSize) {\r\n        alert('File size must be less than 5MB');\r\n        return;\r\n      }\r\n\r\n      this.selectedFile = file;\r\n      \r\n      // Create preview\r\n      const reader = new FileReader();\r\n      reader.onload = (e) => {\r\n        this.imagePreview = e.target?.result as string;\r\n      };\r\n      reader.readAsDataURL(file);\r\n    }\r\n  }\r\n\r\n  removeSelectedImage(): void {\r\n    this.selectedFile = null;\r\n    this.imagePreview = null;\r\n    this.newPost.imageUrl = '';\r\n    \r\n    // Reset file input\r\n    const fileInput = document.getElementById('photo-upload') as HTMLInputElement;\r\n    if (fileInput) {\r\n      fileInput.value = '';\r\n    }\r\n  }\r\n\r\n  // Post dropdown methods\r\n  togglePostDropdown(postId: string): void {\r\n    this.openDropdowns[postId] = !this.openDropdowns[postId];\r\n  }\r\n\r\n  isDropdownOpen(postId: string): boolean {\r\n    return this.openDropdowns[postId] || false;\r\n  }\r\n\r\n  // Post editing methods\r\n  onEditPost(post: Post): void {\r\n    this.editingPost = post;\r\n    this.editPostForm = {\r\n      content: post.content,\r\n      imageUrl: post.imageUrl || ''\r\n    };\r\n    this.isEditingPost = true;\r\n  }\r\n\r\n  onCancelEdit(): void {\r\n    this.editingPost = null;\r\n    this.editPostForm = {\r\n      content: '',\r\n      imageUrl: ''\r\n    };\r\n    this.isEditingPost = false;\r\n  }\r\n\r\n  onSaveEdit(): void {\r\n    if (!this.editingPost || !this.editPostForm.content.trim()) {\r\n      return;\r\n    }\r\n\r\n    this.isSavingPost = true;\r\n\r\n    const updateRequest: UpdatePostRequest = {\r\n      content: this.editPostForm.content.trim(),\r\n      imageUrl: this.editPostForm.imageUrl || undefined\r\n    };\r\n\r\n    this.postsService.updatePost(this.editingPost.postId, updateRequest, this.currentUser.id).subscribe({\r\n      next: (updatedPost) => {\r\n        // Find and update the post in the array\r\n        const index = this.posts.findIndex(p => p.postId === this.editingPost!.postId);\r\n        if (index !== -1) {\r\n          this.posts[index] = this.transformPostForDisplay(updatedPost);\r\n        }\r\n        \r\n        this.onCancelEdit();\r\n        this.isSavingPost = false;\r\n        this.toastService.success('Success!', 'Your post has been updated successfully.');\r\n        console.log('Post updated successfully:', updatedPost);\r\n      },\r\n      error: (error) => {\r\n        console.error('Error updating post:', error);\r\n        this.isSavingPost = false;\r\n        this.toastService.error('Error', 'Failed to update post. Contents of the post are not safe. Please fix contents and try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  // Post deletion methods\r\n  onDeletePost(post: Post): void {\r\n    this.postToDelete = post;\r\n    this.showDeleteModal = true;\r\n  }\r\n\r\n  onConfirmDelete(): void {\r\n    if (!this.postToDelete) return;\r\n\r\n    this.isDeletingPost = true;\r\n\r\n    this.postsService.deletePost(this.postToDelete.postId, this.currentUser.id).subscribe({\r\n      next: () => {\r\n        // Remove the post from the array\r\n        this.posts = this.posts.filter(p => p.postId !== this.postToDelete!.postId);\r\n        this.isDeletingPost = false;\r\n        this.showDeleteModal = false;\r\n        this.postToDelete = null;\r\n        this.toastService.success('Success!', 'Your post has been deleted successfully.');\r\n        console.log('Post deleted successfully');\r\n        \r\n        // Update user statistics (posts count)\r\n        this.loadUserStatistics();\r\n      },\r\n      error: (error) => {\r\n        console.error('Error deleting post:', error);\r\n        this.isDeletingPost = false;\r\n        this.showDeleteModal = false;\r\n        this.postToDelete = null;\r\n        this.toastService.error('Error', 'Failed to delete post. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  onCancelDelete(): void {\r\n    this.showDeleteModal = false;\r\n    this.postToDelete = null;\r\n  }\r\n\r\n  onLogout(): void {\r\n    // Use auth service logout\r\n    this.authService.logout();\r\n    \r\n    // Navigate to login page\r\n    this.router.navigate(['/login']);\r\n  }\r\n\r\n  navigateToSearch(): void {\r\n    this.router.navigate(['/search']);\r\n  }\r\n\r\n  onFollowStatusChanged(): void {\r\n    // Reload posts if on following feed\r\n    if (this.feedType === 'following') {\r\n      this.loadPosts();\r\n    }\r\n    // Reload user statistics to update counts after follow/unfollow\r\n    if (this.currentUser.id) {\r\n      this.loadUserStatistics();\r\n    }\r\n  }\r\n\r\n  loadUserStatistics(): void {\r\n    if (!this.currentUser.id) {\r\n      return;\r\n    }\r\n\r\n    this.isLoadingStats = true;\r\n\r\n    // Load posts count\r\n    this.postsService.getPostsByUser(this.currentUser.id).subscribe({\r\n      next: (posts) => {\r\n        this.userStats.postsCount = posts.length;\r\n        this.isLoadingStats = false;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading posts count:', error);\r\n        this.userStats.postsCount = 0;\r\n        this.isLoadingStats = false;\r\n      }\r\n    });\r\n\r\n    // Load followers count\r\n    this.followsService.getFollowerCount(this.currentUser.id).subscribe({\r\n      next: (response) => {\r\n        this.userStats.followersCount = response.count;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading followers count:', error);\r\n        this.userStats.followersCount = 0;\r\n      }\r\n    });\r\n\r\n    // Load following count\r\n    this.followsService.getFollowingCount(this.currentUser.id).subscribe({\r\n      next: (response) => {\r\n        this.userStats.followingCount = response.count;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading following count:', error);\r\n        this.userStats.followingCount = 0;\r\n      }\r\n    });\r\n  }\r\n\r\n  formatCount(count: number): string {\r\n    if (count >= 1000) {\r\n      return (count / 1000).toFixed(1) + 'K';\r\n    }\r\n    return count.toString();\r\n  }\r\n\r\n  // Comment methods\r\n  toggleComments(postId: string): void {\r\n    this.showComments[postId] = !this.showComments[postId];\r\n  }\r\n\r\n  onCommentsCountChanged(postId: string, newCount: number): void {\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (post) {\r\n      post.commentsCount = newCount;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\login\\login.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\navbar-dropdown\\navbar-dropdown.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\navbar\\navbar.component.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\navbar\\navbar.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\operation-home\\operation-home.component.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":207,"column":11,"nodeType":"MemberExpression","endLine":207,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":211,"column":11,"nodeType":"MemberExpression","endLine":211,"endColumn":42},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":367,"column":5,"nodeType":"MemberExpression","endLine":367,"endColumn":30},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":367,"column":34,"nodeType":"MemberExpression","endLine":367,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":368,"column":9,"nodeType":"MemberExpression","endLine":368,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":385,"column":5,"nodeType":"MemberExpression","endLine":385,"endColumn":35},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":385,"column":39,"nodeType":"MemberExpression","endLine":385,"endColumn":69},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":388,"column":15,"nodeType":"MemberExpression","endLine":388,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, OnInit } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { RouterModule } from '@angular/router';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { UserService, User } from '../../services/user.service';\r\nimport { PostsService } from '../../services/posts.service';\r\nimport { Post, ReportedPost } from '../../interfaces/post.interface';\r\nimport { NavbarComponent } from '../navbar/navbar.component';\r\nimport { ConfirmationModalComponent } from '../confirmation-modal/confirmation-modal.component';\r\nimport { PostCommentsComponent } from '../post-comments/post-comments.component';\r\nimport { AuthService } from '../../services/auth.service';\r\nimport { Router } from '@angular/router';\r\n\r\n@Component({\r\n  selector: 'app-operation-home',\r\n  standalone: true,\r\n  imports: [CommonModule, RouterModule, FormsModule, NavbarComponent, ConfirmationModalComponent, PostCommentsComponent],\r\n  templateUrl: './operation-home.component.html',\r\n  styleUrls: ['./operation-home.component.css']\r\n})\r\nexport class OperationHomeComponent implements OnInit {\r\n  users: User[] = [];\r\n  posts: Post[] = [];\r\n  reportedPosts: ReportedPost[] = [];\r\n  loading = false;\r\n  usersLoading = false;\r\n  postsLoading = false;\r\n  reportedPostsLoading = false;\r\n  error: string | null = null;\r\n  \r\n  // Modal states\r\n  showUserModal = false;\r\n  showPostModal = false;\r\n  pendingUserId: string | null = null;\r\n  pendingPostId: string | null = null;\r\n  pendingAction: 'block' | 'unblock' | 'delete' | null = null;\r\n  isProcessing = false;\r\n\r\n  // Active tab\r\n  activeTab: 'posts' | 'reported' | 'users' = 'reported';\r\n\r\n  // Search/filter\r\n  searchQuery = '';\r\n  filteredPosts: Post[] = [];\r\n  filteredUsers: User[] = [];\r\n\r\n  // Comments\r\n  showComments: { [postId: string]: boolean } = {};\r\n  \r\n  // Report details\r\n  showReportDetails: { [postId: string]: boolean } = {};\r\n\r\n  currentUser = {\r\n    name: '',\r\n    email: '',\r\n    role: '',\r\n    id: '',\r\n    profilePhotoUrl: null as string | null\r\n  };\r\n\r\n  constructor(\r\n    private userService: UserService,\r\n    private postsService: PostsService,\r\n    private authService: AuthService,\r\n    private router: Router\r\n  ) { }\r\n\r\n  ngOnInit(): void {\r\n    this.loadCurrentUser();\r\n    this.loadReportedPosts();\r\n    this.loadPosts();\r\n    this.loadUsers();\r\n  }\r\n\r\n  loadCurrentUser(): void {\r\n    // Get user from authService instead of directly from cookies\r\n    this.authService.currentUser$.subscribe(user => {\r\n      if (user) {\r\n        this.currentUser = {\r\n          name: user.name || '',\r\n          email: user.email || '',\r\n          role: user.role || '',\r\n          id: user.id || '',\r\n          profilePhotoUrl: user.profilePhotoUrl || null\r\n        };\r\n      }\r\n    });\r\n  }\r\n\r\n  loadReportedPosts(): void {\r\n    this.reportedPostsLoading = true;\r\n    this.error = null;\r\n    \r\n    this.postsService.getReportedPosts().subscribe({\r\n      next: (data) => {\r\n        console.log('Reported posts data:', data);\r\n        this.reportedPosts = data;\r\n        // Ensure reports array exists for each post\r\n        this.reportedPosts.forEach(post => {\r\n          if (!post.reports) {\r\n            post.reports = [];\r\n          }\r\n          console.log(`Post ${post.postId} has ${post.reports.length} reports:`, post.reports);\r\n        });\r\n        this.reportedPostsLoading = false;\r\n      },\r\n      error: (err) => {\r\n        this.error = 'Failed to load reported posts';\r\n        this.reportedPostsLoading = false;\r\n        console.error('Error loading reported posts:', err);\r\n      }\r\n    });\r\n  }\r\n\r\n  loadPosts(): void {\r\n    this.postsLoading = true;\r\n    this.error = null;\r\n    \r\n    // Use getAllPosts with proper headers (it should include auth token)\r\n    this.postsService.getAllPosts().subscribe({\r\n      next: (data) => {\r\n        this.posts = data;\r\n        this.filteredPosts = data;\r\n        this.postsLoading = false;\r\n      },\r\n      error: (err) => {\r\n        this.error = 'Failed to load posts';\r\n        this.postsLoading = false;\r\n        console.error(err);\r\n      }\r\n    });\r\n  }\r\n\r\n  loadUsers(): void {\r\n    this.usersLoading = true;\r\n    this.error = null;\r\n    \r\n    this.userService.getAllUsers().subscribe({\r\n      next: (data) => {\r\n        this.users = data;\r\n        this.filteredUsers = data;\r\n        this.usersLoading = false;\r\n      },\r\n      error: (err) => {\r\n        this.error = 'Failed to load users';\r\n        this.usersLoading = false;\r\n        console.error(err);\r\n      }\r\n    });\r\n  }\r\n\r\n  onSearchChange(): void {\r\n    if (this.activeTab === 'posts') {\r\n      if (!this.searchQuery.trim()) {\r\n        this.filteredPosts = this.posts;\r\n      } else {\r\n        const query = this.searchQuery.toLowerCase();\r\n        this.filteredPosts = this.posts.filter(post => \r\n          post.content?.toLowerCase().includes(query) ||\r\n          post.author?.name?.toLowerCase().includes(query) ||\r\n          post.authorName?.toLowerCase().includes(query)\r\n        );\r\n      }\r\n    } else {\r\n      if (!this.searchQuery.trim()) {\r\n        this.filteredUsers = this.users;\r\n      } else {\r\n        const query = this.searchQuery.toLowerCase();\r\n        this.filteredUsers = this.users.filter(user => \r\n          user.name?.toLowerCase().includes(query) ||\r\n          user.email?.toLowerCase().includes(query)\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  blockUser(id: string): void {\r\n    this.pendingUserId = id;\r\n    this.pendingAction = 'block';\r\n    this.showUserModal = true;\r\n  }\r\n\r\n  unblockUser(id: string): void {\r\n    this.pendingUserId = id;\r\n    this.pendingAction = 'unblock';\r\n    this.showUserModal = true;\r\n  }\r\n\r\n  deletePost(id: string): void {\r\n    this.pendingPostId = id;\r\n    this.pendingAction = 'delete';\r\n    this.showPostModal = true;\r\n  }\r\n\r\n  onConfirmUserAction(): void {\r\n    if (!this.pendingUserId || !this.pendingAction) return;\r\n\r\n    this.isProcessing = true;\r\n    const userId = this.pendingUserId;\r\n    const action = this.pendingAction;\r\n\r\n    const handleSuccess = (updatedUser?: User) => {\r\n      this.error = null;\r\n      if (updatedUser) {\r\n        const index = this.users.findIndex(u => u.id === updatedUser.id);\r\n        if (index !== -1) {\r\n          this.users[index] = { ...updatedUser };\r\n        }\r\n        const filterIndex = this.filteredUsers.findIndex(u => u.id === updatedUser.id);\r\n        if (filterIndex !== -1) {\r\n          this.filteredUsers[filterIndex] = { ...updatedUser };\r\n        }\r\n      }\r\n      this.loadUsers();\r\n      this.isProcessing = false;\r\n      this.showUserModal = false;\r\n      this.pendingUserId = null;\r\n      this.pendingAction = null;\r\n    };\r\n\r\n    const handleError = (err: unknown) => {\r\n      this.isProcessing = false;\r\n      console.error(`Failed to ${action} user`, err);\r\n      const errorMessage = err && typeof err === 'object' && 'error' in err && err.error && typeof err.error === 'object' && 'message' in err.error\r\n        ? String(err.error.message)\r\n        : err && typeof err === 'object' && 'message' in err\r\n        ? String(err.message)\r\n        : 'Unknown error';\r\n      this.error = `Failed to ${action} user: ${errorMessage}`;\r\n      this.showUserModal = false;\r\n      this.pendingUserId = null;\r\n      this.pendingAction = null;\r\n    };\r\n\r\n    if (action === 'block') {\r\n      this.userService.lockUser(userId).subscribe({ \r\n        next: (user) => handleSuccess(user), \r\n        error: handleError \r\n      });\r\n    } else if (action === 'unblock') {\r\n      this.userService.unlockUser(userId).subscribe({ \r\n        next: (user) => handleSuccess(user), \r\n        error: handleError \r\n      });\r\n    }\r\n  }\r\n\r\n  onConfirmPostAction(): void {\r\n    if (!this.pendingPostId || this.pendingAction !== 'delete') return;\r\n\r\n    this.isProcessing = true;\r\n    const postId = this.pendingPostId;\r\n\r\n    this.postsService.deletePost(postId, this.currentUser.id).subscribe({\r\n      next: () => {\r\n        this.error = null;\r\n        // Remove from regular posts\r\n        this.posts = this.posts.filter(p => p.postId !== postId);\r\n        this.filteredPosts = this.filteredPosts.filter(p => p.postId !== postId);\r\n        // Remove from reported posts\r\n        this.reportedPosts = this.reportedPosts.filter(p => p.postId !== postId);\r\n        this.isProcessing = false;\r\n        this.showPostModal = false;\r\n        this.pendingPostId = null;\r\n        this.pendingAction = null;\r\n      },\r\n      error: (err) => {\r\n        this.isProcessing = false;\r\n        console.error('Failed to delete post', err);\r\n        this.error = `Failed to delete post: ${err.error?.message || err.message || 'Unknown error'}`;\r\n        this.showPostModal = false;\r\n        this.pendingPostId = null;\r\n        this.pendingAction = null;\r\n      }\r\n    });\r\n  }\r\n\r\n  onCancelUserModal(): void {\r\n    this.showUserModal = false;\r\n    this.pendingUserId = null;\r\n    this.pendingAction = null;\r\n    this.isProcessing = false;\r\n  }\r\n\r\n  onCancelPostModal(): void {\r\n    this.showPostModal = false;\r\n    this.pendingPostId = null;\r\n    this.pendingAction = null;\r\n    this.isProcessing = false;\r\n  }\r\n\r\n  getUserModalConfig() {\r\n    switch (this.pendingAction) {\r\n      case 'block':\r\n        return {\r\n          title: 'Block User Account',\r\n          message: 'Are you sure you want to block this user account? The user will not be able to log in until the account is unblocked.',\r\n          confirmText: 'Block Account',\r\n          buttonClass: 'bg-amber-600 hover:bg-amber-700'\r\n        };\r\n      case 'unblock':\r\n        return {\r\n          title: 'Unblock User Account',\r\n          message: 'Are you sure you want to unblock this user account? The user will be able to log in again.',\r\n          confirmText: 'Unblock Account',\r\n          buttonClass: 'bg-emerald-600 hover:bg-emerald-700'\r\n        };\r\n      default:\r\n        return {\r\n          title: 'Confirm Action',\r\n          message: 'Are you sure?',\r\n          confirmText: 'Confirm',\r\n          buttonClass: 'bg-amber-600 hover:bg-amber-700'\r\n        };\r\n    }\r\n  }\r\n\r\n  getPostModalConfig() {\r\n    return {\r\n      title: 'Delete Post',\r\n      message: 'Are you sure you want to delete this post? This action cannot be undone.',\r\n      confirmText: 'Delete Post',\r\n      buttonClass: 'bg-red-600 hover:bg-red-700'\r\n    };\r\n  }\r\n\r\n  isAccountBlocked(user: User): boolean {\r\n    if (!user.lockoutEnabled || !user.lockoutEnd) {\r\n      return false;\r\n    }\r\n    const lockoutEnd = new Date(user.lockoutEnd);\r\n    return lockoutEnd > new Date();\r\n  }\r\n\r\n  getBlockStatus(user: User): string {\r\n    if (!user.lockoutEnabled) {\r\n      return 'Active';\r\n    }\r\n    if (!user.lockoutEnd) {\r\n      return 'Active';\r\n    }\r\n    const lockoutEnd = new Date(user.lockoutEnd);\r\n    if (lockoutEnd > new Date()) {\r\n      return `Blocked until ${lockoutEnd.toLocaleString()}`;\r\n    }\r\n    return 'Active';\r\n  }\r\n\r\n  switchTab(tab: 'posts' | 'reported' | 'users'): void {\r\n    this.activeTab = tab;\r\n    this.searchQuery = '';\r\n    if (tab === 'posts') {\r\n      this.filteredPosts = this.posts;\r\n    } else if (tab === 'reported') {\r\n      this.loadReportedPosts();\r\n    } else {\r\n      this.filteredUsers = this.users;\r\n    }\r\n  }\r\n\r\n  formatDate(dateString: string | undefined): string {\r\n    if (!dateString) return 'Unknown';\r\n    return new Date(dateString).toLocaleString();\r\n  }\r\n\r\n  toggleComments(postId: string): void {\r\n    this.showComments[postId] = !this.showComments[postId];\r\n    if (this.showComments[postId]) {\r\n      // Comments will be loaded by the PostCommentsComponent\r\n    }\r\n  }\r\n\r\n  onCommentsCountChanged(postId: string, newCount: number): void {\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (post) {\r\n      post.commentsCount = newCount;\r\n    }\r\n    const filteredPost = this.filteredPosts.find(p => p.postId === postId);\r\n    if (filteredPost) {\r\n      filteredPost.commentsCount = newCount;\r\n    }\r\n  }\r\n\r\n  toggleReportDetails(postId: string): void {\r\n    this.showReportDetails[postId] = !this.showReportDetails[postId];\r\n    const post = this.reportedPosts.find(p => p.postId === postId);\r\n    console.log(`Toggling report details for post ${postId}:`, {\r\n      isOpen: this.showReportDetails[postId],\r\n      hasReports: post?.reports ? post.reports.length : 0,\r\n      reports: post?.reports\r\n    });\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\post-comments\\post-comments.component.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":212,"column":11,"nodeType":"MemberExpression","endLine":212,"endColumn":31},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":216,"column":30,"nodeType":"MemberExpression","endLine":216,"endColumn":50},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":254,"column":59,"nodeType":"MemberExpression","endLine":254,"endColumn":85},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":296,"column":9,"nodeType":"MemberExpression","endLine":296,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, Input, Output, EventEmitter, OnInit, OnChanges, SimpleChanges } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { CommentsService } from '../../services/comments.service';\r\nimport { ToastService } from '../../services/toast.service';\r\nimport { Comment, CreateCommentRequest } from '../../interfaces/comment.interface';\r\nimport { ConfirmationModalComponent } from '../confirmation-modal/confirmation-modal.component';\r\nimport { UserService, User } from '../../services/user.service';\r\nimport { AuthService } from '../../services/auth.service';\r\nimport { environment } from '../../../environments/environment';\r\n\r\n@Component({\r\n  selector: 'app-post-comments',\r\n  standalone: true,\r\n  imports: [CommonModule, FormsModule, ConfirmationModalComponent],\r\n  templateUrl: './post-comments.component.html',\r\n  styleUrl: './post-comments.component.css'\r\n})\r\nexport class PostCommentsComponent implements OnInit, OnChanges {\r\n  @Input() postId!: string;\r\n  @Input() commentsCount: number = 0;\r\n  @Input() currentUserId: string = '';\r\n  @Input() currentUserInitials: string = '';\r\n  @Input() currentUserName: string = '';\r\n  @Input() currentUserEmail: string = '';\r\n  @Input() currentUserProfilePhotoUrl: string | null = null;\r\n  @Input() isOpen: boolean = false;\r\n  @Input() allowCreate: boolean = true; // Allow/disallow creating new comments\r\n\r\n  @Output() commentsCountChanged = new EventEmitter<number>();\r\n  @Output() toggleRequested = new EventEmitter<void>();\r\n\r\n  comments: Comment[] = [];\r\n  isLoadingComments = false;\r\n  newCommentContent: string = '';\r\n  isCreatingComment = false;\r\n  editingCommentId: string | null = null;\r\n  editCommentContent: string = '';\r\n  \r\n  // Delete confirmation modal state\r\n  showDeleteModal = false;\r\n  commentIdToDelete: string | null = null;\r\n  isDeletingComment = false;\r\n\r\n  // Cache for profile photos by user ID\r\n  profilePhotoCache: { [userId: string]: string } = {};\r\n\r\n  constructor(\r\n    private commentsService: CommentsService,\r\n    private toastService: ToastService,\r\n    private userService: UserService,\r\n    private authService: AuthService\r\n  ) {}\r\n\r\n  ngOnInit(): void {\r\n    if (this.isOpen) {\r\n      this.loadComments();\r\n    }\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    // Load comments when component is opened\r\n    if (changes['isOpen'] && changes['isOpen'].currentValue === true && !changes['isOpen'].previousValue) {\r\n      if (this.comments.length === 0) {\r\n        this.loadComments();\r\n      }\r\n    }\r\n  }\r\n\r\n  toggleComments(): void {\r\n    this.toggleRequested.emit();\r\n    if (!this.isOpen && this.comments.length === 0) {\r\n      this.loadComments();\r\n    }\r\n  }\r\n\r\n  loadComments(): void {\r\n    this.isLoadingComments = true;\r\n    \r\n    this.commentsService.getCommentsByPost(this.postId).subscribe({\r\n      next: (comments) => {\r\n        this.comments = comments.map(c => ({\r\n          ...c,\r\n          timeAgo: this.calculateTimeAgo(c.createdAt),\r\n          // Check cache or set profile photo if current user\r\n          profilePhotoUrl: c.userId === this.currentUserId \r\n            ? this.currentUserProfilePhotoUrl \r\n            : this.profilePhotoCache[c.userId] || null\r\n        }));\r\n        \r\n        // Load profile photos for all comment authors\r\n        this.loadProfilePhotosForComments(this.comments);\r\n        this.isLoadingComments = false;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading comments:', error);\r\n        this.isLoadingComments = false;\r\n        this.toastService.error('Error', 'Failed to load comments. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  createComment(): void {\r\n    const content = this.newCommentContent.trim();\r\n    if (!content) {\r\n      return;\r\n    }\r\n\r\n    if (!this.currentUserId) {\r\n      this.toastService.error('Error', 'User not authenticated. Please log in again.');\r\n      return;\r\n    }\r\n\r\n    this.isCreatingComment = true;\r\n\r\n    const request: CreateCommentRequest = {\r\n      postId: this.postId,\r\n      userId: this.currentUserId,\r\n      content: content\r\n    };\r\n\r\n    this.commentsService.createComment(request).subscribe({\r\n      next: (newComment) => {\r\n        // Ensure user info is populated - use current user info if backend doesn't return it\r\n        const commentWithUserInfo: Comment = {\r\n          ...newComment,\r\n          userName: newComment.userName || this.currentUserName,\r\n          userEmail: newComment.userEmail || this.currentUserEmail,\r\n          timeAgo: 'just now',\r\n          profilePhotoUrl: this.currentUserProfilePhotoUrl\r\n        };\r\n        \r\n        this.comments.unshift(commentWithUserInfo);\r\n\r\n        this.newCommentContent = '';\r\n        this.isCreatingComment = false;\r\n        \r\n        // Update comment count\r\n        this.commentsCount++;\r\n        this.commentsCountChanged.emit(this.commentsCount);\r\n        \r\n        this.toastService.success('Success!', 'Your comment has been added.');\r\n      },\r\n      error: (error) => {\r\n        console.error('Error creating comment:', error);\r\n        this.isCreatingComment = false;\r\n        this.toastService.error('Error', 'Failed to add comment.Comment contains toxic or unsafe contenets. Please edit it and try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  deleteComment(commentId: string): void {\r\n    this.commentIdToDelete = commentId;\r\n    this.showDeleteModal = true;\r\n  }\r\n\r\n  onConfirmDelete(): void {\r\n    if (!this.commentIdToDelete) {\r\n      return;\r\n    }\r\n\r\n    this.isDeletingComment = true;\r\n\r\n    this.commentsService.deleteComment(this.commentIdToDelete).subscribe({\r\n      next: () => {\r\n        this.comments = this.comments.filter(c => c.commentId !== this.commentIdToDelete);\r\n\r\n        // Update comment count\r\n        if (this.commentsCount > 0) {\r\n          this.commentsCount--;\r\n          this.commentsCountChanged.emit(this.commentsCount);\r\n        }\r\n\r\n        this.isDeletingComment = false;\r\n        this.showDeleteModal = false;\r\n        this.commentIdToDelete = null;\r\n\r\n        this.toastService.success('Success!', 'Comment deleted successfully.');\r\n      },\r\n      error: (error) => {\r\n        console.error('Error deleting comment:', error);\r\n        this.isDeletingComment = false;\r\n        this.toastService.error('Error', 'Failed to delete comment. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  onCancelDelete(): void {\r\n    this.showDeleteModal = false;\r\n    this.commentIdToDelete = null;\r\n  }\r\n\r\n  startEditComment(comment: Comment): void {\r\n    this.editingCommentId = comment.commentId;\r\n    this.editCommentContent = comment.content;\r\n  }\r\n\r\n  cancelEditComment(): void {\r\n    this.editingCommentId = null;\r\n    this.editCommentContent = '';\r\n  }\r\n\r\n  saveEditComment(commentId: string): void {\r\n    if (!this.editCommentContent.trim()) {\r\n      return;\r\n    }\r\n\r\n    this.commentsService.updateComment(commentId, { content: this.editCommentContent.trim() }).subscribe({\r\n      next: (updatedComment) => {\r\n        const index = this.comments.findIndex(c => c.commentId === commentId);\r\n        if (index !== -1) {\r\n          this.comments[index] = {\r\n            ...updatedComment,\r\n            timeAgo: this.calculateTimeAgo(updatedComment.createdAt),\r\n            // Preserve existing profile photo URL\r\n            profilePhotoUrl: this.comments[index].profilePhotoUrl\r\n          };\r\n        }\r\n\r\n        this.editingCommentId = null;\r\n        this.editCommentContent = '';\r\n        this.toastService.success('Success!', 'Comment updated successfully.');\r\n      },\r\n      error: (error) => {\r\n        console.error('Error updating comment:', error);\r\n        this.toastService.error('Error', 'Failed to update comment.Comment contains toxic or unsafe contenets. Please edit it and try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  isCommentOwner(comment: Comment): boolean {\r\n    return comment.userId === this.currentUserId;\r\n  }\r\n\r\n  getCommentInitials(userName: string, userEmail: string): string {\r\n    if (userName) {\r\n      const names = userName.split(' ');\r\n      if (names.length >= 2) {\r\n        return (names[0][0] + names[names.length - 1][0]).toUpperCase();\r\n      }\r\n      return userName.substring(0, 2).toUpperCase();\r\n    }\r\n    if (userEmail) {\r\n      return userEmail.substring(0, 2).toUpperCase();\r\n    }\r\n    return 'U';\r\n  }\r\n\r\n  private loadProfilePhotosForComments(comments: Comment[]): void {\r\n    // Get unique user IDs from comments (excluding current user)\r\n    const userIds = [...new Set(\r\n      comments\r\n        .map(comment => comment.userId)\r\n        .filter(id => id && id !== this.currentUserId && !this.profilePhotoCache[id])\r\n    )];\r\n    \r\n    // Load profile photos for each unique user\r\n    userIds.forEach(userId => {\r\n      if (userId) {\r\n        this.loadAuthorProfilePhoto(userId);\r\n      }\r\n    });\r\n  }\r\n\r\n  private loadAuthorProfilePhoto(userId: string): void {\r\n    this.userService.getUserById(userId).subscribe({\r\n      next: (user: User) => {\r\n        // Handle both camelCase and PascalCase property names\r\n        const profilePhotoId = user.profilePhotoId;\r\n        if (profilePhotoId) {\r\n          this.loadProfilePhotoUrlForAuthor(userId, profilePhotoId);\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error(`Error loading user ${userId}:`, error);\r\n      }\r\n    });\r\n  }\r\n\r\n  private loadProfilePhotoUrlForAuthor(userId: string, imageId: string): void {\r\n    // environment.apiUrl already includes /api, so we don't need to add it again\r\n    fetch(`${environment.apiUrl}/images/${imageId}/url`, {\r\n      headers: {\r\n        'Authorization': `Bearer ${this.authService.getToken()}`\r\n      }\r\n    })\r\n    .then(response => {\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      return response.json();\r\n    })\r\n    .then(data => {\r\n      if (data && data.url) {\r\n        // Cache the profile photo URL\r\n        this.profilePhotoCache[userId] = data.url;\r\n        \r\n        // Update all comments with this author's profile photo\r\n        this.comments.forEach(comment => {\r\n          if (comment.userId === userId) {\r\n            comment.profilePhotoUrl = data.url;\r\n          }\r\n        });\r\n      }\r\n    })\r\n    .catch(error => {\r\n      console.error(`Error loading profile photo URL for user ${userId}:`, error);\r\n    });\r\n  }\r\n\r\n  private calculateTimeAgo(createdAt: string): string {\r\n    const now = new Date();\r\n    const commentDate = new Date(createdAt);\r\n    const diffInSeconds = Math.floor((now.getTime() - commentDate.getTime()) / 1000);\r\n\r\n    if (diffInSeconds < 60) return 'just now';\r\n    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;\r\n    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;\r\n    return `${Math.floor(diffInSeconds / 86400)}d ago`;\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\post-dropdown\\post-dropdown.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\posts-by-tag\\posts-by-tag.component.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":174,"column":29,"nodeType":"MemberExpression","endLine":174,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":178,"column":7,"nodeType":"MemberExpression","endLine":178,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":207,"column":22,"nodeType":"MemberExpression","endLine":207,"endColumn":52},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":210,"column":28,"nodeType":"MemberExpression","endLine":210,"endColumn":58},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":212,"column":26,"nodeType":"MemberExpression","endLine":212,"endColumn":56},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":266,"column":7,"nodeType":"MemberExpression","endLine":266,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":301,"column":5,"nodeType":"MemberExpression","endLine":301,"endColumn":31},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":301,"column":35,"nodeType":"MemberExpression","endLine":301,"endColumn":61},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":305,"column":12,"nodeType":"MemberExpression","endLine":305,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":309,"column":5,"nodeType":"MemberExpression","endLine":309,"endColumn":30},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":309,"column":34,"nodeType":"MemberExpression","endLine":309,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, OnInit, ChangeDetectorRef } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { Router, RouterModule, ActivatedRoute } from '@angular/router';\r\nimport { PostsService } from '../../services/posts.service';\r\nimport { TagsService } from '../../services/tags.service';\r\nimport { LikesService } from '../../services/likes.service';\r\nimport { FollowsService } from '../../services/follows.service';\r\nimport { AuthService } from '../../services/auth.service';\r\nimport { UserService, User } from '../../services/user.service';\r\nimport { ToastService } from '../../services/toast.service';\r\nimport { Post } from '../../interfaces';\r\nimport { Tag } from '../../interfaces/tag.interface';\r\nimport { PostDropdownComponent } from '../post-dropdown/post-dropdown.component';\r\nimport { PostCommentsComponent } from '../post-comments/post-comments.component';\r\nimport { NavbarDropdownComponent } from '../navbar-dropdown/navbar-dropdown.component';\r\nimport { SearchBarComponent } from '../search-bar/search-bar.component';\r\nimport { environment } from '../../../environments/environment';\r\n\r\n@Component({\r\n  selector: 'app-posts-by-tag',\r\n  standalone: true,\r\n  imports: [\r\n    CommonModule,\r\n    RouterModule,\r\n    PostDropdownComponent,\r\n    PostCommentsComponent,\r\n    NavbarDropdownComponent,\r\n    SearchBarComponent\r\n  ],\r\n  templateUrl: './posts-by-tag.component.html',\r\n  styleUrl: './posts-by-tag.component.css'\r\n})\r\nexport class PostsByTagComponent implements OnInit {\r\n  tagId: string = '';\r\n  tag: Tag | null = null;\r\n  posts: Post[] = [];\r\n  isLoading = false;\r\n  isLoadingTag = false;\r\n  \r\n  currentUser = {\r\n    name: '',\r\n    email: '',\r\n    initials: '',\r\n    role: '',\r\n    id: '',\r\n    profilePhotoUrl: null as string | null\r\n  };\r\n\r\n  openDropdowns: { [postId: string]: boolean } = {};\r\n  showComments: { [postId: string]: boolean } = {};\r\n  profilePhotoCache: { [userId: string]: string | null } = {};\r\n\r\n  constructor(\r\n    private route: ActivatedRoute,\r\n    private router: Router,\r\n    private postsService: PostsService,\r\n    private tagsService: TagsService,\r\n    private likesService: LikesService,\r\n    private followsService: FollowsService,\r\n    private authService: AuthService,\r\n    private userService: UserService,\r\n    private toastService: ToastService,\r\n    private cdr: ChangeDetectorRef\r\n  ) {}\r\n\r\n  ngOnInit(): void {\r\n    this.loadUserData();\r\n    this.route.paramMap.subscribe(params => {\r\n      this.tagId = params.get('tagId') || '';\r\n      if (this.tagId) {\r\n        this.loadTag();\r\n        this.loadPosts();\r\n      }\r\n    });\r\n  }\r\n\r\n  loadUserData(): void {\r\n    this.authService.currentUser$.subscribe(user => {\r\n      if (user) {\r\n        this.currentUser = {\r\n          name: user.username || user.name || 'User',\r\n          email: user.email || '',\r\n          initials: this.getInitials(user.username || user.name || user.email || 'U'),\r\n          role: user.role || 'User',\r\n          id: user.id || '',\r\n          profilePhotoUrl: null\r\n        };\r\n        if (this.currentUser.id) {\r\n          this.loadUserProfile();\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  loadUserProfile(): void {\r\n    if (!this.currentUser.id) return;\r\n    \r\n    this.userService.getCurrentUser().subscribe({\r\n      next: (user: User) => {\r\n        if (user.name) {\r\n          this.currentUser.name = user.name;\r\n          this.currentUser.initials = this.getInitials(user.name);\r\n        }\r\n        if (user.email) {\r\n          this.currentUser.email = user.email;\r\n        }\r\n        \r\n        const profilePhotoId = user.profilePhotoId || user.ProfilePhotoId;\r\n        if (profilePhotoId) {\r\n          // Fetch the profile photo URL through the images endpoint (same as home component)\r\n          fetch(`${environment.apiUrl}/images/${profilePhotoId}/url`, {\r\n            headers: {\r\n              'Authorization': `Bearer ${this.authService.getToken()}`\r\n            }\r\n          })\r\n          .then(response => response.json())\r\n          .then(data => {\r\n            this.currentUser.profilePhotoUrl = data.url;\r\n            this.profilePhotoCache[this.currentUser.id] = data.url;\r\n          })\r\n          .catch(error => {\r\n            console.error('Error loading current user profile photo:', error);\r\n          });\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading user profile:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  loadTag(): void {\r\n    this.isLoadingTag = true;\r\n    this.tagsService.getTagById(this.tagId).subscribe({\r\n      next: (tag) => {\r\n        this.tag = tag;\r\n        this.isLoadingTag = false;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading tag:', error);\r\n        this.isLoadingTag = false;\r\n        this.toastService.error('Error', 'Failed to load tag');\r\n      }\r\n    });\r\n  }\r\n\r\n  loadPosts(): void {\r\n    this.isLoading = true;\r\n    this.postsService.getPostsByTag(this.tagId).subscribe({\r\n      next: (posts) => {\r\n        // Transform posts first\r\n        this.posts = posts.map(post => this.transformPostForDisplay(post));\r\n        // Then load profile photos (which will update the posts as they load)\r\n        this.loadProfilePhotosForPosts();\r\n        this.isLoading = false;\r\n        // Trigger change detection after initial load\r\n        this.cdr.detectChanges();\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading posts:', error);\r\n        this.isLoading = false;\r\n        this.posts = [];\r\n        this.toastService.error('Error', 'Failed to load posts');\r\n      }\r\n    });\r\n  }\r\n\r\n  private transformPostForDisplay(apiPost: Partial<Post> & { userId: string; createdAt: string }): Post {\r\n    // Use backend author information if available, otherwise fallback to current user\r\n    const authorName = apiPost.authorName || apiPost.author?.name || 'Unknown User';\r\n    const userId = apiPost.userId;\r\n    \r\n    // Check if we already have profile photo in cache\r\n    const profilePhotoUrl = this.profilePhotoCache[userId] || null;\r\n    \r\n    // If it's the current user, use their profile photo\r\n    if (userId === this.currentUser.id && this.currentUser.profilePhotoUrl) {\r\n      this.profilePhotoCache[userId] = this.currentUser.profilePhotoUrl;\r\n    }\r\n\r\n    return {\r\n      ...apiPost,\r\n      timeAgo: this.getTimeAgo(apiPost.createdAt),\r\n      author: {\r\n        name: authorName,\r\n        initials: this.getInitials(authorName),\r\n        userId: userId,\r\n        profilePhotoUrl: profilePhotoUrl || (userId === this.currentUser.id ? this.currentUser.profilePhotoUrl : null)\r\n      },\r\n      authorName: authorName\r\n    };\r\n  }\r\n\r\n  private loadProfilePhotosForPosts(): void {\r\n    // Get unique user IDs from posts (use author.userId like home component)\r\n    const userIds = [...new Set(\r\n      this.posts\r\n        .map(post => post.author?.userId || post.userId)\r\n        .filter(id => id && id !== this.currentUser.id)\r\n    )];\r\n    \r\n    console.log('loadProfilePhotosForPosts - User IDs:', userIds);\r\n    console.log('loadProfilePhotosForPosts - Posts:', this.posts);\r\n    \r\n    // Load profile photos for each unique user that doesn't have a cached photo\r\n    userIds.forEach(userId => {\r\n      if (userId && !this.profilePhotoCache[userId]) {\r\n        console.log(`Loading profile photo for user: ${userId}`);\r\n        this.loadAuthorProfilePhoto(userId);\r\n      } else if (userId && this.profilePhotoCache[userId]) {\r\n        // If we already have it cached, update the posts immediately\r\n        const photoUrl = this.profilePhotoCache[userId];\r\n        console.log(`Using cached profile photo for user: ${userId}`, photoUrl);\r\n        this.posts = this.posts.map(post => {\r\n          const postUserId = post.author?.userId || post.userId;\r\n          if (postUserId === userId && post.author) {\r\n            console.log(`Updated post ${post.postId} with cached profile photo`);\r\n            return {\r\n              ...post,\r\n              author: {\r\n                ...post.author,\r\n                profilePhotoUrl: photoUrl\r\n              }\r\n            };\r\n          }\r\n          return post;\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Trigger change detection after checking cache\r\n    this.cdr.detectChanges();\r\n  }\r\n\r\n  private loadAuthorProfilePhoto(userId: string): void {\r\n    this.userService.getUserById(userId).subscribe({\r\n      next: (user: User) => {\r\n        if (user.profilePhotoId) {\r\n          this.loadProfilePhotoUrlForAuthor(userId, user.profilePhotoId);\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error(`Error loading user ${userId}:`, error);\r\n      }\r\n    });\r\n  }\r\n\r\n  private loadProfilePhotoUrlForAuthor(userId: string, imageId: string): void {\r\n    console.log(`loadProfilePhotoUrlForAuthor - userId: ${userId}, imageId: ${imageId}`);\r\n    // environment.apiUrl already includes /api, so we don't need to add it again\r\n    fetch(`${environment.apiUrl}/images/${imageId}/url`, {\r\n      headers: {\r\n        'Authorization': `Bearer ${localStorage.getItem('accessToken')}`\r\n      }\r\n    })\r\n    .then(response => {\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      return response.json();\r\n    })\r\n    .then(data => {\r\n      // Cache the profile photo URL\r\n      const photoUrl = data.url;\r\n      console.log(`Profile photo URL loaded for user ${userId}:`, photoUrl);\r\n      this.profilePhotoCache[userId] = photoUrl;\r\n      \r\n      // Update all posts with this author's profile photo\r\n      let updated = false;\r\n      this.posts = this.posts.map(post => {\r\n        const postUserId = post.author?.userId || post.userId;\r\n        if (postUserId === userId && post.author) {\r\n          console.log(`Updating post ${post.postId} author profile photo`);\r\n          updated = true;\r\n          return {\r\n            ...post,\r\n            author: {\r\n              ...post.author,\r\n              profilePhotoUrl: photoUrl\r\n            }\r\n          };\r\n        }\r\n        return post;\r\n      });\r\n      \r\n      console.log(`Updated ${updated ? 'posts' : 'no posts'} with profile photo for user ${userId}`);\r\n      console.log('Posts after update:', this.posts);\r\n      \r\n      // Always trigger change detection when we get a new photo\r\n      if (updated) {\r\n        this.cdr.detectChanges();\r\n      }\r\n    })\r\n    .catch(error => {\r\n      console.error(`Error loading profile photo URL for user ${userId}:`, error);\r\n      // Don't cache failed requests\r\n    });\r\n  }\r\n\r\n  togglePostDropdown(postId: string): void {\r\n    this.openDropdowns[postId] = !this.openDropdowns[postId];\r\n  }\r\n\r\n  isDropdownOpen(postId: string): boolean {\r\n    return this.openDropdowns[postId] || false;\r\n  }\r\n\r\n  toggleComments(postId: string): void {\r\n    this.showComments[postId] = !this.showComments[postId];\r\n  }\r\n\r\n  onCommentsCountChanged(postId: string, newCount: number): void {\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (post) {\r\n      post.commentsCount = newCount;\r\n    }\r\n  }\r\n\r\n  likePost(postId: string): void {\r\n    this.likesService.likePost(postId).subscribe({\r\n      next: () => {\r\n        const post = this.posts.find(p => p.postId === postId);\r\n        if (post) {\r\n          post.isLikedByCurrentUser = true;\r\n          post.likesCount++;\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error('Error liking post:', error);\r\n        this.toastService.error('Error', 'Failed to like post');\r\n      }\r\n    });\r\n  }\r\n\r\n  unlikePost(postId: string): void {\r\n    this.likesService.unlikePost(postId).subscribe({\r\n      next: () => {\r\n        const post = this.posts.find(p => p.postId === postId);\r\n        if (post) {\r\n          post.isLikedByCurrentUser = false;\r\n          post.likesCount--;\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error('Error unliking post:', error);\r\n        this.toastService.error('Error', 'Failed to unlike post');\r\n      }\r\n    });\r\n  }\r\n\r\n  navigateToSearch(): void {\r\n    this.router.navigate(['/search']);\r\n  }\r\n\r\n  onLogout(): void {\r\n    this.authService.logout();\r\n    this.router.navigate(['/login']);\r\n  }\r\n\r\n  getInitials(name: string): string {\r\n    if (!name) return 'U';\r\n    const words = name.trim().split(/\\s+/);\r\n    if (words.length === 1) {\r\n      return words[0].substring(0, 2).toUpperCase();\r\n    }\r\n    return (words[0].charAt(0) + words[words.length - 1].charAt(0)).toUpperCase();\r\n  }\r\n\r\n  getTimeAgo(dateString: string): string {\r\n    const date = new Date(dateString);\r\n    const now = new Date();\r\n    const seconds = Math.floor((now.getTime() - date.getTime()) / 1000);\r\n    \r\n    if (seconds < 60) return 'just now';\r\n    const minutes = Math.floor(seconds / 60);\r\n    if (minutes < 60) return `${minutes}m ago`;\r\n    const hours = Math.floor(minutes / 60);\r\n    if (hours < 24) return `${hours}h ago`;\r\n    const days = Math.floor(hours / 24);\r\n    if (days < 7) return `${days}d ago`;\r\n    const weeks = Math.floor(days / 7);\r\n    if (weeks < 4) return `${weeks}w ago`;\r\n    const months = Math.floor(days / 30);\r\n    return `${months}mo ago`;\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\profile-card\\profile-card.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\register\\register.component.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'response' is defined but never used. Allowed unused args must match /^_/u.","line":78,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":78,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { FormBuilder, FormGroup, ReactiveFormsModule, Validators, AbstractControl, ValidationErrors } from '@angular/forms';\r\nimport { Router, RouterModule } from '@angular/router';\r\nimport { TotpSetupComponent } from '../totp-setup/totp-setup.component';\r\nimport { EmailVerificationComponent } from '../email-verification/email-verification.component';\r\nimport { AuthService } from '../../services/auth.service';\r\n\r\n@Component({\r\n  selector: 'app-register',\r\n  standalone: true,\r\n  imports: [CommonModule, ReactiveFormsModule, RouterModule, TotpSetupComponent, EmailVerificationComponent],\r\n  templateUrl: './register.component.html',\r\n  styleUrls: ['./register.component.css']\r\n})\r\nexport class RegisterComponent {\r\n  registerForm: FormGroup;\r\n  isLoading = false;\r\n  errorMessage = '';\r\n  currentStep = 1; // 1: Registration, 2: Email Verification, 3: TOTP Setup\r\n  userEmail = '';\r\n\r\n  constructor(\r\n    private fb: FormBuilder,\r\n    private router: Router,\r\n    private authService: AuthService\r\n  ) {\r\n    this.registerForm = this.fb.group({\r\n      name: ['', [Validators.required, Validators.minLength(2)]],\r\n      email: ['', [Validators.required, Validators.email]],\r\n      password: ['', [Validators.required, Validators.minLength(10), this.passwordComplexityValidator]],\r\n      confirmPassword: ['', [Validators.required]]\r\n    }, { validators: this.passwordMatchValidator });\r\n  }\r\n\r\n  // Custom validator for password complexity\r\n  passwordComplexityValidator(control: AbstractControl): ValidationErrors | null {\r\n    const password = control.value;\r\n    if (!password) {\r\n      return null;\r\n    }\r\n\r\n    const hasUpperCase = /[A-Z]/.test(password);\r\n    const specialChars = /[@$!%*?#^~]/;\r\n    const hasSpecialChar = specialChars.test(password);\r\n\r\n    if (!hasUpperCase && !hasSpecialChar) {\r\n      return { passwordComplexity: { message: 'Password must contain at least one uppercase letter and one special character (@$!%*?#^~).' } };\r\n    } else if (!hasUpperCase) {\r\n      return { passwordComplexity: { message: 'Password must contain at least one uppercase letter.' } };\r\n    } else if (!hasSpecialChar) {\r\n      return { passwordComplexity: { message: 'Password must contain at least one special character (@$!%*?#^~).' } };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  passwordMatchValidator(form: FormGroup) {\r\n    const password = form.get('password');\r\n    const confirmPassword = form.get('confirmPassword');\r\n    \r\n    if (password && confirmPassword && password.value !== confirmPassword.value) {\r\n      confirmPassword.setErrors({ passwordMismatch: true });\r\n      return { passwordMismatch: true };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  onSubmit() {\r\n    if (this.registerForm.valid) {\r\n      this.isLoading = true;\r\n      this.errorMessage = '';\r\n      \r\n      const { name, email, password } = this.registerForm.value;\r\n      this.userEmail = email;\r\n      \r\n      this.authService.register({ name, email, password }).subscribe({\r\n        next: (response) => {\r\n          this.isLoading = false;\r\n          // Always move to email verification step\r\n          this.currentStep = 2;\r\n        },\r\n        error: (error) => {\r\n          this.isLoading = false;\r\n          this.errorMessage = error.error?.message || 'Registration failed';\r\n        }\r\n      });\r\n    } else {\r\n      this.errorMessage = 'Please fill in all fields correctly';\r\n    }\r\n  }\r\n\r\n  onEmailVerified() {\r\n    // Email verified, move to TOTP setup\r\n    this.currentStep = 3;\r\n  }\r\n\r\n  onEmailVerificationBack() {\r\n    // Go back to registration step\r\n    this.currentStep = 1;\r\n  }\r\n\r\n  onTotpCompleted() {\r\n    // Registration complete, redirect to home\r\n    this.router.navigate(['/home']);\r\n  }\r\n\r\n  onTotpBack() {\r\n    // Go back to email verification step\r\n    this.currentStep = 2;\r\n  }\r\n\r\n  registerWithGoogle() {\r\n    this.authService.googleLogin();\r\n  }\r\n\r\n  registerWithFacebook() {\r\n    console.log('Register with Facebook');\r\n    // TODO: Implement Facebook OAuth\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\report-modal\\report-modal.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\reset-password\\reset-password.component.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'response' is defined but never used. Allowed unused args must match /^_/u.","line":153,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, OnInit } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport {\r\n  FormBuilder,\r\n  FormGroup,\r\n  ReactiveFormsModule,\r\n  Validators,\r\n  AbstractControl,\r\n  ValidationErrors,\r\n} from '@angular/forms';\r\nimport { Router, RouterModule, ActivatedRoute } from '@angular/router';\r\nimport { AuthService } from '../../services/auth.service';\r\n\r\n@Component({\r\n  selector: 'app-reset-password',\r\n  standalone: true,\r\n  imports: [CommonModule, ReactiveFormsModule, RouterModule],\r\n  templateUrl: './reset-password.component.html',\r\n  styleUrls: ['./reset-password.component.css'],\r\n})\r\nexport class ResetPasswordComponent implements OnInit {\r\n  resetPasswordForm: FormGroup;\r\n  isLoading = false;\r\n  errorMessage = '';\r\n  successMessage = '';\r\n  token = '';\r\n  isTokenValid = false;\r\n\r\n  constructor(\r\n    private fb: FormBuilder,\r\n    private router: Router,\r\n    private route: ActivatedRoute,\r\n    private authService: AuthService\r\n  ) {\r\n    this.resetPasswordForm = this.fb.group(\r\n      {\r\n        password: ['', [Validators.required, Validators.minLength(10), this.passwordComplexityValidator]],\r\n        confirmPassword: ['', [Validators.required]],\r\n      },\r\n      { validators: this.passwordMatchValidator }\r\n    );\r\n  }\r\n\r\n  // Custom validator for password complexity\r\n  passwordComplexityValidator(control: AbstractControl): ValidationErrors | null {\r\n    const password = control.value;\r\n    if (!password) {\r\n      return null;\r\n    }\r\n\r\n    const hasUpperCase = /[A-Z]/.test(password);\r\n    const specialChars = /[@$!%*?#^~]/;\r\n    const hasSpecialChar = specialChars.test(password);\r\n\r\n    if (!hasUpperCase && !hasSpecialChar) {\r\n      return { passwordComplexity: { message: 'Password must contain at least one uppercase letter and one special character (@$!%*?#^~).' } };\r\n    } else if (!hasUpperCase) {\r\n      return { passwordComplexity: { message: 'Password must contain at least one uppercase letter.' } };\r\n    } else if (!hasSpecialChar) {\r\n      return { passwordComplexity: { message: 'Password must contain at least one special character (@$!%*?#^~).' } };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  hasSpecialChar(password: string | null | undefined): boolean {\r\n    if (!password) return false;\r\n    const specialChars = /[@$!%*?#^~]/;\r\n    return specialChars.test(password);\r\n  }\r\n\r\n  hasUpperCase(password: string | null | undefined): boolean {\r\n    if (!password) return false;\r\n    return /[A-Z]/.test(password);\r\n  }\r\n\r\n  ngOnInit() {\r\n    // Get token from URL parameters\r\n    this.route.queryParams.subscribe((params) => {\r\n      this.token = params['token'];\r\n      if (this.token) {\r\n        this.validateToken();\r\n      } else {\r\n        this.errorMessage = 'Invalid or missing reset token.';\r\n      }\r\n    });\r\n  }\r\n\r\n  passwordMatchValidator(form: FormGroup) {\r\n    const password = form.get('password');\r\n    const confirmPassword = form.get('confirmPassword');\r\n\r\n    if (\r\n      password &&\r\n      confirmPassword &&\r\n      password.value !== confirmPassword.value\r\n    ) {\r\n      confirmPassword.setErrors({ passwordMismatch: true });\r\n      return { passwordMismatch: true };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  validateToken() {\r\n    this.isLoading = true;\r\n    console.log('Validating token:', this.token);\r\n    console.log('Token length:', this.token?.length);\r\n    console.log('Token type:', typeof this.token);\r\n    this.authService.validateResetToken(this.token).subscribe({\r\n      next: (response) => {\r\n        console.log('Token validation response:', response);\r\n        console.log('Response type:', typeof response);\r\n        console.log('Response isValid:', response?.isValid);\r\n        console.log('Response message:', response?.message);\r\n        this.isLoading = false;\r\n        if (response && response.isValid) {\r\n          this.isTokenValid = true;\r\n          console.log('Token is valid, enabling form');\r\n        } else {\r\n          this.isTokenValid = false;\r\n          this.errorMessage = response?.message || 'Invalid or expired reset token.';\r\n          console.log('Token is invalid:', this.errorMessage);\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error('Token validation error:', error);\r\n        console.error('Error status:', error.status);\r\n        console.error('Error message:', error.message);\r\n        console.error('Error body:', error.error);\r\n        this.isLoading = false;\r\n        this.isTokenValid = false;\r\n        this.errorMessage =\r\n          'Invalid or expired reset token. Please request a new password reset.';\r\n      },\r\n    });\r\n  }\r\n\r\n  onSubmit() {\r\n    if (this.resetPasswordForm.valid && this.isTokenValid) {\r\n      this.isLoading = true;\r\n      this.errorMessage = '';\r\n      this.successMessage = '';\r\n\r\n      const { password, confirmPassword } = this.resetPasswordForm.value;\r\n      console.log('Form values:', { password: '***', confirmPassword: '***', token: this.token });\r\n      console.log('Password length:', password?.length);\r\n      console.log('Passwords match:', password === confirmPassword);\r\n\r\n      this.authService\r\n        .resetPassword(this.token, password, confirmPassword)\r\n        .subscribe({\r\n          next: (response) => {\r\n            this.isLoading = false;\r\n            this.successMessage =\r\n              'Your password has been successfully reset. You can now sign in with your new password.';\r\n            setTimeout(() => {\r\n              this.router.navigate(['/login']);\r\n            }, 3000);\r\n          },\r\n          error: (error) => {\r\n            console.error('Password reset error:', error);\r\n            console.error('Error status:', error.status);\r\n            console.error('Error body:', error.error);\r\n            console.error('Validation errors:', error.error?.errors);\r\n            this.isLoading = false;\r\n            if (error.status === 400) {\r\n              this.errorMessage = error.error?.message || 'Invalid or expired reset token.';\r\n            } else {\r\n              this.errorMessage = 'An error occurred. Please try again later.';\r\n            }\r\n          },\r\n        });\r\n    } else {\r\n      this.errorMessage = 'Please fill in all fields correctly.';\r\n    }\r\n  }\r\n\r\n  goToLogin() {\r\n    this.router.navigate(['/login']);\r\n  }\r\n\r\n  goToForgotPassword() {\r\n    this.router.navigate(['/forgot-password']);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\search-bar\\search-bar.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\search-results\\search-results.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\suggested-users\\suggested-users.component.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":58,"column":9,"nodeType":"MemberExpression","endLine":58,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":62,"column":9,"nodeType":"MemberExpression","endLine":62,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":85,"column":25,"nodeType":"MemberExpression","endLine":85,"endColumn":53},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":93,"column":9,"nodeType":"MemberExpression","endLine":93,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":150,"column":9,"nodeType":"MemberExpression","endLine":150,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":154,"column":9,"nodeType":"MemberExpression","endLine":154,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":160,"column":25,"nodeType":"MemberExpression","endLine":160,"endColumn":53},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":168,"column":9,"nodeType":"MemberExpression","endLine":168,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, OnInit } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { RouterModule } from '@angular/router';\r\nimport { UsersService } from '../../services/users.service';\r\nimport { FollowsService } from '../../services/follows.service';\r\nimport { SuggestedUser } from '../../interfaces';\r\n\r\n@Component({\r\n  selector: 'app-suggested-users',\r\n  standalone: true,\r\n  imports: [CommonModule, RouterModule],\r\n  templateUrl: './suggested-users.component.html',\r\n  styleUrl: './suggested-users.component.css'\r\n})\r\nexport class SuggestedUsersComponent implements OnInit {\r\n  suggestedUsers: SuggestedUser[] = [];\r\n  isLoading = false;\r\n  followingStatus: { [userId: string]: boolean } = {};\r\n  showAllModal = false;\r\n  allSuggestedUsers: SuggestedUser[] = [];\r\n  isLoadingAll = false;\r\n\r\n  constructor(\r\n    private usersService: UsersService,\r\n    private followsService: FollowsService\r\n  ) {}\r\n\r\n  ngOnInit(): void {\r\n    this.loadSuggestedUsers();\r\n  }\r\n\r\n  loadSuggestedUsers(): void {\r\n    this.isLoading = true;\r\n    this.usersService.getSuggestedUsers(8).subscribe({\r\n      next: (users) => {\r\n        this.suggestedUsers = users.map(user => ({\r\n          ...user,\r\n          initials: this.getInitials(user.name || user.username || user.email)\r\n        }));\r\n        this.isLoading = false;\r\n        // Check follow status for each user\r\n        users.forEach(user => {\r\n          this.checkFollowStatus(user.id);\r\n        });\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading suggested users:', error);\r\n        this.isLoading = false;\r\n        // Fallback to empty array\r\n        this.suggestedUsers = [];\r\n      }\r\n    });\r\n  }\r\n\r\n  checkFollowStatus(userId: string): void {\r\n    this.followsService.getFollowStatus(userId).subscribe({\r\n      next: (status) => {\r\n        this.followingStatus[userId] = status.isFollowing;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error checking follow status:', error);\r\n        this.followingStatus[userId] = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  getInitials(name: string): string {\r\n    if (!name) return 'U';\r\n    \r\n    // If it's an email, use first letter\r\n    if (name.includes('@')) {\r\n      return name.charAt(0).toUpperCase();\r\n    }\r\n    \r\n    // Split by space and get first letter of each word\r\n    const words = name.trim().split(' ');\r\n    if (words.length === 1) {\r\n      return words[0].substring(0, 2).toUpperCase();\r\n    }\r\n    \r\n    return (words[0].charAt(0) + words[words.length - 1].charAt(0)).toUpperCase();\r\n  }\r\n\r\n  onFollowUser(userId: string): void {\r\n    const isFollowing = this.followingStatus[userId];\r\n    \r\n    const action = isFollowing \r\n      ? this.followsService.unfollowUser(userId)\r\n      : this.followsService.followUser(userId);\r\n\r\n    action.subscribe({\r\n      next: () => {\r\n        this.followingStatus[userId] = !isFollowing;\r\n        // Remove user from suggested list if they just followed (not if unfollowing)\r\n        if (!isFollowing) {\r\n          this.suggestedUsers = this.suggestedUsers.filter(u => u.id !== userId);\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error('Error following/unfollowing user:', error);\r\n        alert('Failed to ' + (isFollowing ? 'unfollow' : 'follow') + ' user. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  onRefresh(): void {\r\n    this.loadSuggestedUsers();\r\n  }\r\n\r\n  trackByUserId(index: number, user: SuggestedUser): string {\r\n    return user.id;\r\n  }\r\n\r\n  trackByIndex(index: number, _item: SuggestedUser): number {\r\n    return index;\r\n  }\r\n\r\n  onViewAll(): void {\r\n    this.showAllModal = true;\r\n    this.loadAllSuggestedUsers();\r\n  }\r\n\r\n  loadAllSuggestedUsers(): void {\r\n    this.isLoadingAll = true;\r\n    this.usersService.getSuggestedUsers(50).subscribe({\r\n      next: (users) => {\r\n        this.allSuggestedUsers = users.map(user => ({\r\n          ...user,\r\n          initials: this.getInitials(user.name || user.username || user.email)\r\n        }));\r\n        this.isLoadingAll = false;\r\n        // Check follow status for each user (only if not already checked)\r\n        users.forEach(user => {\r\n          if (this.followingStatus[user.id] === undefined) {\r\n            this.checkFollowStatusForAll(user.id);\r\n          }\r\n        });\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading all suggested users:', error);\r\n        this.isLoadingAll = false;\r\n        this.allSuggestedUsers = [];\r\n      }\r\n    });\r\n  }\r\n\r\n  checkFollowStatusForAll(userId: string): void {\r\n    this.followsService.getFollowStatus(userId).subscribe({\r\n      next: (status) => {\r\n        this.followingStatus[userId] = status.isFollowing;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error checking follow status:', error);\r\n        this.followingStatus[userId] = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  onFollowUserInModal(userId: string): void {\r\n    const isFollowing = this.followingStatus[userId];\r\n    \r\n    const action = isFollowing \r\n      ? this.followsService.unfollowUser(userId)\r\n      : this.followsService.followUser(userId);\r\n\r\n    action.subscribe({\r\n      next: () => {\r\n        this.followingStatus[userId] = !isFollowing;\r\n        // Update in both lists\r\n        this.suggestedUsers.forEach(u => {\r\n          if (u.id === userId) {\r\n            // Update follow status\r\n          }\r\n        });\r\n        this.allSuggestedUsers.forEach(u => {\r\n          if (u.id === userId) {\r\n            // Update follow status\r\n          }\r\n        });\r\n        // Remove from suggested list if they just followed (not if unfollowing)\r\n        if (!isFollowing) {\r\n          this.suggestedUsers = this.suggestedUsers.filter(u => u.id !== userId);\r\n          this.allSuggestedUsers = this.allSuggestedUsers.filter(u => u.id !== userId);\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error('Error following/unfollowing user:', error);\r\n        alert('Failed to ' + (isFollowing ? 'unfollow' : 'follow') + ' user. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  closeModal(): void {\r\n    this.showAllModal = false;\r\n    this.allSuggestedUsers = [];\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\toast\\toast.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\totp-setup\\totp-setup.component.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":50,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, Input, Output, EventEmitter } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';\r\nimport { AuthService, TotpSetupResponse } from '../../services/auth.service';\r\n\r\n@Component({\r\n  selector: 'app-totp-setup',\r\n  standalone: true,\r\n  imports: [CommonModule, ReactiveFormsModule],\r\n  templateUrl: './totp-setup.component.html',\r\n  styleUrls: ['./totp-setup.component.css']\r\n})\r\nexport class TotpSetupComponent {\r\n  @Input() email: string = '';\r\n  @Output() completed = new EventEmitter<void>();\r\n  @Output() back = new EventEmitter<void>();\r\n\r\n  totpForm: FormGroup;\r\n  isLoading = false;\r\n  errorMessage = '';\r\n  successMessage = '';\r\n  totpData: TotpSetupResponse | null = null;\r\n  showManualEntry = false;\r\n  currentStep = 1; // 1: Setup, 2: Verify\r\n\r\n  constructor(\r\n    private fb: FormBuilder,\r\n    private authService: AuthService\r\n  ) {\r\n    this.totpForm = this.fb.group({\r\n      code: ['', [Validators.required, Validators.pattern(/^\\d{6}$/)]]\r\n    });\r\n  }\r\n\r\n  ngOnInit() {\r\n    this.setupTotp();\r\n  }\r\n\r\n  setupTotp() {\r\n    this.isLoading = true;\r\n    this.errorMessage = '';\r\n    \r\n    // Try regular setup first, if it fails (user exists), use existing user setup\r\n    this.authService.setupTotp(this.email).subscribe({\r\n      next: (response) => {\r\n        this.isLoading = false;\r\n        this.totpData = response;\r\n        this.currentStep = 1;\r\n      },\r\n      error: (error) => {\r\n        // If regular setup fails, try setup for existing user (allows reconfiguration)\r\n        this.authService.setupTotpForExistingUser(this.email).subscribe({\r\n          next: (response) => {\r\n            this.isLoading = false;\r\n            this.totpData = response;\r\n            this.currentStep = 1;\r\n          },\r\n          error: (error) => {\r\n            this.isLoading = false;\r\n            this.errorMessage = error.error?.message || 'Failed to setup TOTP';\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  onVerifyTotp() {\r\n    if (this.totpForm.valid) {\r\n      this.isLoading = true;\r\n      this.errorMessage = '';\r\n      \r\n      const { code } = this.totpForm.value;\r\n      \r\n      this.authService.verifyTotp(this.email, code).subscribe({\r\n        next: () => {\r\n          this.isLoading = false;\r\n          this.successMessage = 'TOTP setup completed successfully!';\r\n          setTimeout(() => {\r\n            this.completed.emit();\r\n          }, 1500);\r\n        },\r\n        error: (error) => {\r\n          this.isLoading = false;\r\n          this.errorMessage = error.error?.message || 'Invalid TOTP code';\r\n        }\r\n      });\r\n    } else {\r\n      this.errorMessage = 'Please enter a valid 6-digit code';\r\n    }\r\n  }\r\n\r\n  onBack() {\r\n    this.back.emit();\r\n  }\r\n\r\n  toggleManualEntry() {\r\n    this.showManualEntry = !this.showManualEntry;\r\n  }\r\n\r\n  copyToClipboard(text: string) {\r\n    navigator.clipboard.writeText(text).then(() => {\r\n      // You could add a toast notification here\r\n      console.log('Copied to clipboard');\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\user-list\\user-list.component.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":136,"column":11,"nodeType":"MemberExpression","endLine":136,"endColumn":28},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":245,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":245,"endColumn":103,"suggestions":[{"messageId":"addBrackets","fix":{"range":[7944,8333],"text":"{ const roleLabel = this.roles.find(r => r.value === this.editingRoleValue)?.label || 'Unknown';\r\n        return {\r\n          title: 'Change User Role',\r\n          message: `Are you sure you want to change this user's role to ${roleLabel}? This will affect their access permissions.`,\r\n          confirmText: 'Change Role',\r\n          buttonClass: 'bg-blue-600 hover:bg-blue-700'\r\n        }; }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, OnInit } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { RouterModule } from '@angular/router';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { UserService, User } from '../../services/user.service';\r\nimport { NavbarComponent } from '../navbar/navbar.component';\r\nimport { ConfirmationModalComponent } from '../confirmation-modal/confirmation-modal.component';\r\nimport { normalizeRole } from '../../utils/role.util';\r\n\r\n@Component({\r\n  selector: 'app-user-list',\r\n  standalone: true,\r\n  imports: [CommonModule, RouterModule, FormsModule, NavbarComponent, ConfirmationModalComponent],\r\n  templateUrl: './user-list.component.html',\r\n  styleUrls: ['./user-list.component.css']\r\n})\r\nexport class UserListComponent implements OnInit {\r\n  users: User[] = [];\r\n  loading = false;\r\n  error: string | null = null;\r\n  showModal = false;\r\n  pendingUserId: string | null = null;\r\n  pendingAction: 'delete' | 'lock' | 'unlock' | 'changeRole' | null = null;\r\n  isProcessing = false;\r\n  \r\n  // Role change\r\n  editingRoleUserId: string | null = null;\r\n  editingRoleValue: number | null = null;\r\n  \r\n  // Available roles\r\n  roles = [\r\n    { value: 0, label: 'User' },\r\n    { value: 1, label: 'Admin' },\r\n    { value: 2, label: 'Moderator' },\r\n    { value: 3, label: 'Operation' }\r\n  ];\r\n\r\n  constructor(private userService: UserService) { }\r\n\r\n  ngOnInit(): void {\r\n    this.loadUsers();\r\n  }\r\n\r\n  loadUsers(): void {\r\n    this.loading = true;\r\n    this.error = null;\r\n    \r\n    this.userService.getAllUsers().subscribe({\r\n      next: (data) => {\r\n        this.users = data;\r\n        this.loading = false;\r\n      },\r\n      error: (err) => {\r\n        this.error = 'Failed to load users';\r\n        this.loading = false;\r\n        console.error(err);\r\n      }\r\n    });\r\n  }\r\n\r\n  deleteUser(id: string): void {\r\n    this.pendingUserId = id;\r\n    this.pendingAction = 'delete';\r\n    this.showModal = true;\r\n  }\r\n\r\n  lockUser(id: string): void {\r\n    this.pendingUserId = id;\r\n    this.pendingAction = 'lock';\r\n    this.showModal = true;\r\n  }\r\n\r\n  unlockUser(id: string): void {\r\n    this.pendingUserId = id;\r\n    this.pendingAction = 'unlock';\r\n    this.showModal = true;\r\n  }\r\n\r\n  changeUserRole(userId: string, newRole: number): void {\r\n    this.pendingUserId = userId;\r\n    this.pendingAction = 'changeRole';\r\n    this.editingRoleValue = newRole;\r\n    this.showModal = true;\r\n  }\r\n\r\n  startEditRole(userId: string): void {\r\n    const user = this.users.find(u => u.id === userId);\r\n    if (user) {\r\n      // Get role as number (handle both string and number)\r\n      let roleValue = 0;\r\n      if (typeof user.role === 'number') {\r\n        roleValue = user.role;\r\n      } else if (typeof user.role === 'string') {\r\n        const roleMap: { [key: string]: number } = {\r\n          'User': 0,\r\n          'Admin': 1,\r\n          'Moderator': 2,\r\n          'Operation': 3\r\n        };\r\n        roleValue = roleMap[user.role] ?? 0;\r\n      }\r\n      this.editingRoleUserId = userId;\r\n      this.editingRoleValue = roleValue;\r\n    }\r\n  }\r\n\r\n  cancelEditRole(): void {\r\n    this.editingRoleUserId = null;\r\n    this.editingRoleValue = null;\r\n  }\r\n\r\n  saveRoleChange(userId: string): void {\r\n    if (this.editingRoleValue === null || this.editingRoleValue === undefined) return;\r\n    \r\n    this.pendingUserId = userId;\r\n    this.pendingAction = 'changeRole';\r\n    this.showModal = true;\r\n  }\r\n\r\n  onConfirm(): void {\r\n    if (!this.pendingUserId || !this.pendingAction) return;\r\n\r\n    this.isProcessing = true;\r\n    const userId = this.pendingUserId;\r\n    const action = this.pendingAction;\r\n\r\n    const handleSuccess = (updatedUser?: User) => {\r\n      // Clear any previous errors\r\n      this.error = null;\r\n      \r\n      // Update the local user object if we got an updated user back\r\n      if (updatedUser) {\r\n        const index = this.users.findIndex(u => u.id === updatedUser.id);\r\n        if (index !== -1) {\r\n          // Create a new object reference to trigger Angular change detection\r\n          this.users[index] = { ...updatedUser };\r\n        }\r\n      }\r\n      \r\n      // Always reload to ensure consistency with the server\r\n      this.loadUsers();\r\n      \r\n      this.isProcessing = false;\r\n      this.showModal = false;\r\n      this.pendingUserId = null;\r\n      this.pendingAction = null;\r\n    };\r\n\r\n    const handleError = (err: unknown) => {\r\n      this.isProcessing = false;\r\n      console.error(`Failed to ${action} user`, err);\r\n      // Extract validation errors if present\r\n      let errorMessage = 'Unknown error';\r\n      if (err && typeof err === 'object') {\r\n        if ('error' in err && err.error && typeof err.error === 'object') {\r\n          if ('message' in err.error) {\r\n            errorMessage = String(err.error.message);\r\n          }\r\n          if ('errors' in err.error && err.error.errors && typeof err.error.errors === 'object') {\r\n            const validationErrors = Object.entries(err.error.errors)\r\n              .map(([key, value]) => `${key}: ${Array.isArray(value) ? value.join(', ') : String(value)}`)\r\n              .join('; ');\r\n            errorMessage = `Validation errors: ${validationErrors}`;\r\n          }\r\n        } else if ('message' in err) {\r\n          errorMessage = String(err.message);\r\n        }\r\n      }\r\n      this.error = `Failed to ${action} user: ${errorMessage}`;\r\n      this.showModal = false;\r\n      this.pendingUserId = null;\r\n      this.pendingAction = null;\r\n    };\r\n\r\n    if (action === 'delete') {\r\n      this.userService.deleteUser(userId).subscribe({ \r\n        next: () => handleSuccess(), \r\n        error: handleError \r\n      });\r\n    } else if (action === 'lock') {\r\n      this.userService.lockUser(userId).subscribe({ \r\n        next: (user) => handleSuccess(user), \r\n        error: handleError \r\n      });\r\n    } else if (action === 'unlock') {\r\n      this.userService.unlockUser(userId).subscribe({ \r\n        next: (user) => handleSuccess(user), \r\n        error: handleError \r\n      });\r\n    } else if (action === 'changeRole') {\r\n      if (this.editingRoleValue === null || this.editingRoleValue === undefined) {\r\n        handleError({ message: 'Role value is required' });\r\n        return;\r\n      }\r\n      // Update user role only - ensure it's sent as a number\r\n      const roleValue = typeof this.editingRoleValue === 'string' \r\n        ? parseInt(this.editingRoleValue, 10) \r\n        : this.editingRoleValue;\r\n      this.userService.updateUser(userId, { \r\n        role: roleValue \r\n      }).subscribe({\r\n        next: (user) => {\r\n          handleSuccess(user);\r\n          this.editingRoleUserId = null;\r\n          this.editingRoleValue = null;\r\n        },\r\n        error: handleError\r\n      });\r\n    }\r\n  }\r\n\r\n  onCancelModal(): void {\r\n    this.showModal = false;\r\n    this.pendingUserId = null;\r\n    this.pendingAction = null;\r\n    this.isProcessing = false;\r\n    this.editingRoleUserId = null;\r\n    this.editingRoleValue = null;\r\n  }\r\n\r\n  getModalConfig() {\r\n    switch (this.pendingAction) {\r\n      case 'delete':\r\n        return {\r\n          title: 'Delete User',\r\n          message: 'Are you sure you want to delete this user? This action cannot be undone.',\r\n          confirmText: 'Delete',\r\n          buttonClass: 'bg-red-600 hover:bg-red-700'\r\n        };\r\n      case 'lock':\r\n        return {\r\n          title: 'Lock User Account',\r\n          message: 'Are you sure you want to lock this user account? The user will not be able to log in until the account is unlocked.',\r\n          confirmText: 'Lock Account',\r\n          buttonClass: 'bg-yellow-600 hover:bg-yellow-700'\r\n        };\r\n      case 'unlock':\r\n        return {\r\n          title: 'Unlock User Account',\r\n          message: 'Are you sure you want to unlock this user account? The user will be able to log in again.',\r\n          confirmText: 'Unlock Account',\r\n          buttonClass: 'bg-green-600 hover:bg-green-700'\r\n        };\r\n      case 'changeRole':\r\n        const roleLabel = this.roles.find(r => r.value === this.editingRoleValue)?.label || 'Unknown';\r\n        return {\r\n          title: 'Change User Role',\r\n          message: `Are you sure you want to change this user's role to ${roleLabel}? This will affect their access permissions.`,\r\n          confirmText: 'Change Role',\r\n          buttonClass: 'bg-blue-600 hover:bg-blue-700'\r\n        };\r\n      default:\r\n        return {\r\n          title: 'Confirm Action',\r\n          message: 'Are you sure?',\r\n          confirmText: 'Confirm',\r\n          buttonClass: 'bg-blue-600 hover:bg-blue-700'\r\n        };\r\n    }\r\n  }\r\n\r\n  isAccountLocked(user: User): boolean {\r\n    if (!user.lockoutEnabled || !user.lockoutEnd) {\r\n      return false;\r\n    }\r\n    const lockoutEnd = new Date(user.lockoutEnd);\r\n    return lockoutEnd > new Date();\r\n  }\r\n\r\n  getLockoutStatus(user: User): string {\r\n    if (!user.lockoutEnabled) {\r\n      return 'Disabled';\r\n    }\r\n    if (!user.lockoutEnd) {\r\n      return 'Active';\r\n    }\r\n    const lockoutEnd = new Date(user.lockoutEnd);\r\n    if (lockoutEnd > new Date()) {\r\n      return `Locked until ${lockoutEnd.toLocaleString()}`;\r\n    }\r\n    return 'Active';\r\n  }\r\n\r\n  getUserRole(user: User): string {\r\n    return normalizeRole(user.role);\r\n  }\r\n\r\n  getUserRoleValue(user: User): number {\r\n    if (typeof user.role === 'number') {\r\n      return user.role;\r\n    }\r\n    if (typeof user.role === 'string') {\r\n      const roleMap: { [key: string]: number } = {\r\n        'User': 0,\r\n        'Admin': 1,\r\n        'Moderator': 2,\r\n        'Operation': 3\r\n      };\r\n      return roleMap[user.role] ?? 0;\r\n    }\r\n    return 0;\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\components\\user-profile\\user-profile.component.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":212,"column":21,"nodeType":"MemberExpression","endLine":212,"endColumn":52},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":225,"column":11,"nodeType":"MemberExpression","endLine":225,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7613,7616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7613,7616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":260,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8575,8578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8575,8578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":264,"column":5,"nodeType":"MemberExpression","endLine":264,"endColumn":31},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":264,"column":35,"nodeType":"MemberExpression","endLine":264,"endColumn":61},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":268,"column":12,"nodeType":"MemberExpression","endLine":268,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":272,"column":5,"nodeType":"MemberExpression","endLine":272,"endColumn":30},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":272,"column":34,"nodeType":"MemberExpression","endLine":272,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":294,"column":11,"nodeType":"MemberExpression","endLine":294,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":369,"column":9,"nodeType":"MemberExpression","endLine":369,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":378,"column":7,"nodeType":"MemberExpression","endLine":378,"endColumn":40},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":383,"column":5,"nodeType":"MemberExpression","endLine":383,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":384,"column":5,"nodeType":"MemberExpression","endLine":384,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":391,"column":9,"nodeType":"MemberExpression","endLine":391,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":396,"column":9,"nodeType":"MemberExpression","endLine":396,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":403,"column":9,"nodeType":"MemberExpression","endLine":403,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":419,"column":5,"nodeType":"MemberExpression","endLine":419,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":425,"column":9,"nodeType":"MemberExpression","endLine":425,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":430,"column":9,"nodeType":"MemberExpression","endLine":430,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":440,"column":5,"nodeType":"MemberExpression","endLine":440,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":440,"column":42,"nodeType":"MemberExpression","endLine":440,"endColumn":75},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":444,"column":5,"nodeType":"MemberExpression","endLine":444,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, OnInit } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { Router, RouterModule, ActivatedRoute } from '@angular/router';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { UserService, User } from '../../services/user.service';\r\nimport { PostsService } from '../../services/posts.service';\r\nimport { Post } from '../../interfaces';\r\nimport { FollowsService } from '../../services/follows.service';\r\nimport { AuthService } from '../../services/auth.service';\r\nimport { NavbarDropdownComponent } from '../navbar-dropdown/navbar-dropdown.component';\r\nimport { PostDropdownComponent } from '../post-dropdown/post-dropdown.component';\r\nimport { PostCommentsComponent } from '../post-comments/post-comments.component';\r\nimport { ConfirmationModalComponent } from '../confirmation-modal/confirmation-modal.component';\r\nimport { ToastService } from '../../services/toast.service';\r\nimport { LikesService } from '../../services/likes.service';\r\nimport { environment } from '../../../environments/environment';\r\n\r\n@Component({\r\n  selector: 'app-user-profile',\r\n  standalone: true,\r\n  imports: [\r\n    CommonModule,\r\n    RouterModule,\r\n    FormsModule,\r\n    NavbarDropdownComponent,\r\n    PostDropdownComponent,\r\n    PostCommentsComponent,\r\n    ConfirmationModalComponent\r\n  ],\r\n  templateUrl: './user-profile.component.html',\r\n  styleUrl: './user-profile.component.css'\r\n})\r\nexport class UserProfileComponent implements OnInit {\r\n  userId: string = '';\r\n  user: User | null = null;\r\n  posts: Post[] = [];\r\n  isLoading = false;\r\n  isLoadingPosts = false;\r\n  isFollowing = false;\r\n  isLoadingFollowStatus = false;\r\n  currentUser: { id?: string; name?: string; email?: string; role?: string | number } | null = null;\r\n  \r\n  // Post interaction states\r\n  openDropdowns: { [postId: string]: boolean } = {};\r\n  showComments: { [postId: string]: boolean } = {};\r\n  showDeleteModal = false;\r\n  postToDelete: Post | null = null;\r\n  editingPost: Post | null = null;\r\n  editPostForm = {\r\n    content: '',\r\n    imageUrl: ''\r\n  };\r\n  isSavingPost = false;\r\n  isDeletingPost = false;\r\n\r\n  // Translation and summarization states\r\n  translatingPosts: { [postId: string]: boolean } = {};\r\n  summarizingPosts: { [postId: string]: boolean } = {};\r\n  translationLanguage: string = 'en';\r\n  showLanguageSelector: { [postId: string]: boolean } = {};\r\n  \r\n  availableLanguages = [\r\n    { code: 'en', name: 'English' },\r\n    { code: 'ar', name: 'Arabic' },\r\n    { code: 'fr', name: 'French' },\r\n    { code: 'es', name: 'Spanish' },\r\n    { code: 'de', name: 'German' },\r\n    { code: 'it', name: 'Italian' },\r\n    { code: 'pt', name: 'Portuguese' },\r\n    { code: 'ru', name: 'Russian' },\r\n    { code: 'ja', name: 'Japanese' },\r\n    { code: 'ko', name: 'Korean' },\r\n    { code: 'zh', name: 'Chinese' },\r\n    { code: 'hi', name: 'Hindi' },\r\n    { code: 'tr', name: 'Turkish' },\r\n    { code: 'pl', name: 'Polish' },\r\n    { code: 'nl', name: 'Dutch' },\r\n    { code: 'sv', name: 'Swedish' },\r\n    { code: 'da', name: 'Danish' },\r\n    { code: 'no', name: 'Norwegian' },\r\n    { code: 'fi', name: 'Finnish' },\r\n    { code: 'cs', name: 'Czech' }\r\n  ];\r\n\r\n  // Profile photo cache\r\n  profilePhotoCache: { [userId: string]: string } = {};\r\n\r\n  constructor(\r\n    private route: ActivatedRoute,\r\n    private router: Router,\r\n    private userService: UserService,\r\n    private postsService: PostsService,\r\n    private followsService: FollowsService,\r\n    private authService: AuthService,\r\n    private toastService: ToastService,\r\n    private likesService: LikesService\r\n  ) {}\r\n\r\n  ngOnInit(): void {\r\n    // Get current user\r\n    this.authService.currentUser$.subscribe(user => {\r\n      this.currentUser = user;\r\n    });\r\n\r\n    // Get userId from route params\r\n    this.route.params.subscribe(params => {\r\n      this.userId = params['userId'];\r\n      if (this.userId) {\r\n        this.loadUserProfile();\r\n        this.loadUserPosts();\r\n        if (this.currentUser?.id) {\r\n          this.checkFollowStatus();\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  loadUserProfile(): void {\r\n    this.isLoading = true;\r\n    this.userService.getUserById(this.userId).subscribe({\r\n      next: (user) => {\r\n        this.user = user;\r\n        this.isLoading = false;\r\n        // Load profile photo if available\r\n        if (user.profilePhotoId) {\r\n          this.loadProfilePhotoUrl(user.profilePhotoId);\r\n        }\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading user profile:', error);\r\n        this.isLoading = false;\r\n        this.toastService.error('Error', 'Failed to load user profile.');\r\n        this.router.navigate(['/home']);\r\n      }\r\n    });\r\n  }\r\n\r\n  loadUserPosts(): void {\r\n    this.isLoadingPosts = true;\r\n    this.postsService.getPostsByUser(this.userId).subscribe({\r\n      next: (posts) => {\r\n        this.posts = posts.map(post => this.transformPostForDisplay(post));\r\n        this.isLoadingPosts = false;\r\n        \r\n        // Load profile photos for all post authors\r\n        posts.forEach(post => {\r\n          if (post.author?.userId && !this.profilePhotoCache[post.author.userId]) {\r\n            // Profile photo loading would be handled if needed\r\n          }\r\n        });\r\n      },\r\n      error: (error) => {\r\n        console.error('Error loading user posts:', error);\r\n        this.isLoadingPosts = false;\r\n        this.toastService.error('Error', 'Failed to load user posts.');\r\n      }\r\n    });\r\n  }\r\n\r\n  checkFollowStatus(): void {\r\n    if (!this.currentUser?.id || this.currentUser.id === this.userId) {\r\n      return; // Don't check if viewing own profile\r\n    }\r\n    \r\n    this.isLoadingFollowStatus = true;\r\n    this.followsService.getFollowStatus(this.userId).subscribe({\r\n      next: (response) => {\r\n        this.isFollowing = response.isFollowing;\r\n        this.isLoadingFollowStatus = false;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error checking follow status:', error);\r\n        this.isFollowing = false;\r\n        this.isLoadingFollowStatus = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  onFollowToggle(): void {\r\n    if (!this.currentUser?.id) {\r\n      this.toastService.error('Error', 'Please log in to follow users.');\r\n      return;\r\n    }\r\n\r\n    if (this.currentUser.id === this.userId) {\r\n      return; // Can't follow yourself\r\n    }\r\n\r\n    this.isLoadingFollowStatus = true;\r\n    const action = this.isFollowing\r\n      ? this.followsService.unfollowUser(this.userId)\r\n      : this.followsService.followUser(this.userId);\r\n\r\n    action.subscribe({\r\n      next: () => {\r\n        this.isFollowing = !this.isFollowing;\r\n        this.isLoadingFollowStatus = false;\r\n        this.toastService.success(\r\n          this.isFollowing ? 'Following' : 'Unfollowed',\r\n          this.isFollowing ? `You are now following ${this.user?.name}` : `You unfollowed ${this.user?.name}`\r\n        );\r\n      },\r\n      error: (error) => {\r\n        console.error('Error toggling follow:', error);\r\n        this.isLoadingFollowStatus = false;\r\n        this.toastService.error('Error', 'Failed to update follow status.');\r\n      }\r\n    });\r\n  }\r\n\r\n  loadProfilePhotoUrl(imageId: string): void {\r\n    if (!imageId || this.profilePhotoCache[imageId]) {\r\n      return;\r\n    }\r\n\r\n    const url = `${environment.apiUrl}/images/${imageId}/url`;\r\n    fetch(url, {\r\n      headers: {\r\n        'Authorization': `Bearer ${this.authService.getToken()}`\r\n      }\r\n    })\r\n      .then(response => response.json())\r\n      .then(data => {\r\n        if (data && data.url) {\r\n          this.profilePhotoCache[imageId] = data.url;\r\n          if (this.user) {\r\n            (this.user as any).profilePhotoUrl = data.url;\r\n          }\r\n        }\r\n      })\r\n      .catch(error => {\r\n        console.error('Error loading profile photo:', error);\r\n      });\r\n  }\r\n\r\n  transformPostForDisplay(post: Post): Post {\r\n    // Transform post similar to home component\r\n    if (post.authorName && !post.author) {\r\n      post.author = {\r\n        name: post.authorName,\r\n        initials: this.getInitials(post.authorName),\r\n        userId: post.userId,\r\n        profilePhotoUrl: this.profilePhotoCache[post.userId] || null\r\n      };\r\n    }\r\n    return post;\r\n  }\r\n\r\n  getInitials(name: string): string {\r\n    if (!name) return 'U';\r\n    const words = name.trim().split(' ');\r\n    if (words.length === 1) {\r\n      return words[0].substring(0, 2).toUpperCase();\r\n    }\r\n    return (words[0].charAt(0) + words[words.length - 1].charAt(0)).toUpperCase();\r\n  }\r\n\r\n  getUserProfilePhotoUrl(): string | null {\r\n    if (!this.user) return null;\r\n    return (this.user as any).profilePhotoUrl || this.profilePhotoCache[this.user.profilePhotoId || ''] || null;\r\n  }\r\n\r\n  togglePostDropdown(postId: string): void {\r\n    this.openDropdowns[postId] = !this.openDropdowns[postId];\r\n  }\r\n\r\n  isDropdownOpen(postId: string): boolean {\r\n    return this.openDropdowns[postId] || false;\r\n  }\r\n\r\n  toggleComments(postId: string): void {\r\n    this.showComments[postId] = !this.showComments[postId];\r\n  }\r\n\r\n  onEditPost(post: Post): void {\r\n    this.editingPost = post;\r\n    this.editPostForm.content = post.content;\r\n    this.editPostForm.imageUrl = post.imageUrl || '';\r\n  }\r\n\r\n  onSaveEdit(): void {\r\n    if (!this.editingPost) return;\r\n\r\n    this.isSavingPost = true;\r\n    const updateRequest = {\r\n      content: this.editPostForm.content.trim(),\r\n      imageUrl: this.editPostForm.imageUrl.trim() || undefined\r\n    };\r\n\r\n    this.postsService.updatePost(this.editingPost.postId, updateRequest, this.currentUser.id).subscribe({\r\n      next: (updatedPost) => {\r\n        const index = this.posts.findIndex(p => p.postId === updatedPost.postId);\r\n        if (index !== -1) {\r\n          this.posts[index] = this.transformPostForDisplay(updatedPost);\r\n        }\r\n        this.editingPost = null;\r\n        this.editPostForm = { content: '', imageUrl: '' };\r\n        this.isSavingPost = false;\r\n        this.toastService.success('Success', 'Post updated successfully.');\r\n      },\r\n      error: (error) => {\r\n        console.error('Error updating post:', error);\r\n        this.isSavingPost = false;\r\n        this.toastService.error('Error', 'Failed to update post.');\r\n      }\r\n    });\r\n  }\r\n\r\n  onDeletePost(post: Post): void {\r\n    this.postToDelete = post;\r\n    this.showDeleteModal = true;\r\n  }\r\n\r\n  onConfirmDelete(): void {\r\n    if (!this.postToDelete) return;\r\n\r\n    this.isDeletingPost = true;\r\n    this.postsService.deletePost(this.postToDelete.postId, this.currentUser.id).subscribe({\r\n      next: () => {\r\n        this.posts = this.posts.filter(p => p.postId !== this.postToDelete!.postId);\r\n        this.showDeleteModal = false;\r\n        this.postToDelete = null;\r\n        this.isDeletingPost = false;\r\n        this.toastService.success('Success', 'Post deleted successfully.');\r\n      },\r\n      error: (error) => {\r\n        console.error('Error deleting post:', error);\r\n        this.isDeletingPost = false;\r\n        this.toastService.error('Error', 'Failed to delete post.');\r\n      }\r\n    });\r\n  }\r\n\r\n  onCancelDelete(): void {\r\n    this.showDeleteModal = false;\r\n    this.postToDelete = null;\r\n  }\r\n\r\n  likePost(postId: string): void {\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (!post) return;\r\n\r\n    const wasLiked = post.isLikedByCurrentUser;\r\n    post.isLikedByCurrentUser = !wasLiked;\r\n    post.likesCount += post.isLikedByCurrentUser ? 1 : -1;\r\n\r\n    this.likesService.toggleLike(postId).subscribe({\r\n      next: (response) => {\r\n        post.isLikedByCurrentUser = response.isLiked ?? post.isLikedByCurrentUser;\r\n        post.likesCount = response.likesCount;\r\n      },\r\n      error: (error) => {\r\n        console.error('Error toggling like:', error);\r\n        post.isLikedByCurrentUser = wasLiked;\r\n        post.likesCount += post.isLikedByCurrentUser ? 1 : -1;\r\n        this.toastService.error('Error', 'Failed to update like.');\r\n      }\r\n    });\r\n  }\r\n\r\n  onCommentsCountChanged(postId: string, newCount: number): void {\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (post) {\r\n      post.commentsCount = newCount;\r\n    }\r\n  }\r\n\r\n  translatePost(postId: string, language?: string): void {\r\n    if (this.translatingPosts[postId]) return;\r\n\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (!post) return;\r\n\r\n    if (post.isTranslated && post.translatedContent && !language) {\r\n      post.isTranslated = false;\r\n      post.translatedContent = undefined;\r\n      post.translationLanguage = undefined;\r\n      this.showLanguageSelector[postId] = false;\r\n      return;\r\n    }\r\n\r\n    const targetLanguage = language || this.translationLanguage;\r\n    this.showLanguageSelector[postId] = false;\r\n    this.translatingPosts[postId] = true;\r\n\r\n    this.postsService.translatePost(postId, targetLanguage).subscribe({\r\n      next: (response) => {\r\n        post.translatedContent = response.translated;\r\n        post.isTranslated = true;\r\n        post.translationLanguage = response.language;\r\n        this.translatingPosts[postId] = false;\r\n        this.toastService.success('Translated', `Post has been translated to ${this.getLanguageName(response.language)}.`);\r\n      },\r\n      error: (error) => {\r\n        console.error('Error translating post:', error);\r\n        this.translatingPosts[postId] = false;\r\n        this.toastService.error('Translation Failed', 'Failed to translate post. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  summarizePost(postId: string): void {\r\n    if (this.summarizingPosts[postId]) return;\r\n\r\n    const post = this.posts.find(p => p.postId === postId);\r\n    if (!post) return;\r\n\r\n    if (post.isSummarized && post.summarizedContent) {\r\n      post.isSummarized = false;\r\n      post.summarizedContent = undefined;\r\n      if (post.isTranslated) {\r\n        post.isTranslated = false;\r\n        post.translatedContent = undefined;\r\n        post.translationLanguage = undefined;\r\n      }\r\n      return;\r\n    }\r\n\r\n    this.summarizingPosts[postId] = true;\r\n\r\n    this.postsService.summarizePost(postId).subscribe({\r\n      next: (response) => {\r\n        post.summarizedContent = response.summary;\r\n        post.isSummarized = true;\r\n        this.summarizingPosts[postId] = false;\r\n        this.toastService.success('Summarized', 'Post has been summarized successfully.');\r\n      },\r\n      error: (error) => {\r\n        console.error('Error summarizing post:', error);\r\n        this.summarizingPosts[postId] = false;\r\n        this.toastService.error('Summarization Failed', 'Failed to summarize post. Please try again.');\r\n      }\r\n    });\r\n  }\r\n\r\n  toggleLanguageSelector(postId: string, event?: Event): void {\r\n    if (event) {\r\n      event.stopPropagation();\r\n    }\r\n    this.showLanguageSelector[postId] = !this.showLanguageSelector[postId];\r\n  }\r\n\r\n  closeLanguageSelector(postId: string): void {\r\n    this.showLanguageSelector[postId] = false;\r\n  }\r\n\r\n  getLanguageName(code: string): string {\r\n    const lang = this.availableLanguages.find(l => l.code === code);\r\n    return lang ? lang.name : code.toUpperCase();\r\n  }\r\n\r\n  get isOwnProfile(): boolean {\r\n    return this.currentUser?.id === this.userId;\r\n  }\r\n\r\n  formatDate(dateString: string): string {\r\n    const date = new Date(dateString);\r\n    const now = new Date();\r\n    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);\r\n    \r\n    if (diffInSeconds < 60) {\r\n      return 'just now';\r\n    } else if (diffInSeconds < 3600) {\r\n      const minutes = Math.floor(diffInSeconds / 60);\r\n      return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;\r\n    } else if (diffInSeconds < 86400) {\r\n      const hours = Math.floor(diffInSeconds / 3600);\r\n      return `${hours} hour${hours > 1 ? 's' : ''} ago`;\r\n    } else if (diffInSeconds < 604800) {\r\n      const days = Math.floor(diffInSeconds / 86400);\r\n      return `${days} day${days > 1 ? 's' : ''} ago`;\r\n    } else {\r\n      return date.toLocaleDateString();\r\n    }\r\n  }\r\n\r\n  onFollowStatusChanged(): void {\r\n    // Refresh follow status if needed\r\n    if (this.currentUser?.id) {\r\n      this.checkFollowStatus();\r\n    }\r\n  }\r\n\r\n  onLogout(): void {\r\n    this.authService.logout();\r\n    this.router.navigate(['/login']);\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\guards\\auth.guard.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'route' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { inject } from '@angular/core';\r\nimport { Router, CanActivateFn } from '@angular/router';\r\nimport { AuthService } from '../services/auth.service';\r\n\r\nexport const authGuard: CanActivateFn = (route, state) => {\r\n  const authService = inject(AuthService);\r\n  const router = inject(Router);\r\n\r\n  if (authService.isAuthenticated()) {\r\n    return true;\r\n  }\r\n  \r\n  router.navigate(['/login']);\r\n  return false;\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\guards\\role.guard.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'route' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { inject } from '@angular/core';\r\nimport { Router, CanActivateFn } from '@angular/router';\r\nimport { AuthService } from '../services/auth.service';\r\nimport { normalizeRole, hasRole } from '../utils/role.util';\r\n\r\nexport const roleGuard = (allowedRoles: string[]): CanActivateFn => {\r\n  return (route, state) => {\r\n    const authService = inject(AuthService);\r\n    const router = inject(Router);\r\n\r\n    // Check if user is authenticated\r\n    if (!authService.isAuthenticated()) {\r\n      router.navigate(['/login']);\r\n      return false;\r\n    }\r\n\r\n    // Get user from authService synchronously\r\n    const user = authService.getCurrentUser();\r\n    if (!user) {\r\n      router.navigate(['/login']);\r\n      return false;\r\n    }\r\n\r\n    const userRole = user.role;\r\n\r\n    // Check if user has required role (handles both numeric and string)\r\n    if (hasRole(userRole, allowedRoles)) {\r\n      return true;\r\n    }\r\n\r\n    // User doesn't have permission, redirect based on their role\r\n    const normalizedRole = normalizeRole(userRole);\r\n    if (normalizedRole === 'Operation') {\r\n      router.navigate(['/operation']);\r\n    } else {\r\n      router.navigate(['/home']);\r\n    }\r\n    return false;\r\n  };\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\interceptors\\auth.interceptor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[539,542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[539,542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@angular/core';\r\nimport { HttpInterceptor, HttpRequest, HttpHandler, HttpErrorResponse } from '@angular/common/http';\r\nimport { catchError, switchMap, throwError } from 'rxjs';\r\nimport { AuthService } from '../services/auth.service';\r\nimport { Router } from '@angular/router';\r\n\r\n@Injectable()\r\nexport class AuthInterceptor implements HttpInterceptor {\r\n  private isRefreshing = false;\r\n\r\n  constructor(\r\n    private authService: AuthService,\r\n    private router: Router\r\n  ) {}\r\n\r\n  intercept(req: HttpRequest<any>, next: HttpHandler) {\r\n    const token = this.authService.getToken();\r\n    \r\n    if (token) {\r\n      req = req.clone({\r\n        setHeaders: {\r\n          Authorization: `Bearer ${token}`\r\n        }\r\n      });\r\n    }\r\n\r\n    return next.handle(req).pipe(\r\n      catchError((error: HttpErrorResponse) => {\r\n        // Don't try to refresh if the request is to the refresh endpoint itself\r\n        if (error.status === 401 && !req.url.includes('/auth/refresh')) {\r\n          // Prevent multiple simultaneous refresh attempts\r\n          if (!this.isRefreshing) {\r\n            this.isRefreshing = true;\r\n            \r\n            // Try to refresh the token\r\n            return this.authService.refreshToken().pipe(\r\n              switchMap(() => {\r\n                this.isRefreshing = false;\r\n                const newToken = this.authService.getToken();\r\n                if (newToken) {\r\n                  req = req.clone({\r\n                    setHeaders: {\r\n                      Authorization: `Bearer ${newToken}`\r\n                    }\r\n                  });\r\n                  return next.handle(req);\r\n                } else {\r\n                  // No token after refresh, logout\r\n                  this.authService.logout();\r\n                  this.router.navigate(['/login']);\r\n                  return throwError(() => error);\r\n                }\r\n              }),\r\n              catchError((refreshError) => {\r\n                this.isRefreshing = false;\r\n                // Refresh failed, logout user\r\n                this.authService.logout();\r\n                this.router.navigate(['/login']);\r\n                return throwError(() => refreshError);\r\n              })\r\n            );\r\n          } else {\r\n            // Already refreshing, wait a bit and retry original request\r\n            return throwError(() => error);\r\n          }\r\n        }\r\n        \r\n        // If it's a 401 on the refresh endpoint or other errors, just throw\r\n        return throwError(() => error);\r\n      })\r\n    );\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\interfaces\\comment.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\interfaces\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\interfaces\\post.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\interfaces\\suggested-user.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\interfaces\\tag.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\interfaces\\trending-topic.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\auth.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1224,1227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1224,1227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":70,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4233,4236],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4233,4236],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4679,4682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4679,4682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4815,4818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4815,4818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":201,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5713,5716],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5713,5716],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6625,6628],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6625,6628],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6776,6779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6776,6779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { BehaviorSubject, Observable, tap, catchError } from 'rxjs';\r\nimport { environment } from '../../environments/environment';\r\nimport { CookieService } from './cookie.service';\r\n\r\nexport interface LoginRequest {\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\nexport interface RegisterRequest {\r\n  name: string;\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\nexport interface AuthResponse {\r\n  accessToken: string;\r\n  refreshToken: string;\r\n  expiresIn: number;\r\n  requiresTotp?: boolean;\r\n  user: {\r\n    id: string;\r\n    name: string;\r\n    email: string;\r\n    username?: string;\r\n    role?: string;\r\n  };\r\n}\r\n\r\nexport interface TotpSetupRequest {\r\n  email: string;\r\n}\r\n\r\nexport interface TotpSetupResponse {\r\n  qrCodeUrl: string;\r\n  secretKey: string;\r\n  manualEntryKey: string;\r\n}\r\n\r\nexport interface TotpVerificationRequest {\r\n  email: string;\r\n  code: string;\r\n}\r\n\r\nexport interface EmailVerificationRequest {\r\n  email: string;\r\n  code: string;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class AuthService {\r\n  private apiUrl = `${environment.apiUrl}/auth`;\r\n  private currentUserSubject = new BehaviorSubject<any>(null);\r\n  public currentUser$ = this.currentUserSubject.asObservable();\r\n\r\n  constructor(\r\n    private http: HttpClient,\r\n    private cookieService: CookieService\r\n  ) {\r\n    // Load user from cookies on init\r\n    const token = this.cookieService.get('accessToken');\r\n    const user = this.cookieService.get('user');\r\n    if (token && user) {\r\n      try {\r\n        this.currentUserSubject.next(JSON.parse(user));\r\n      } catch (e) {\r\n        // Invalid JSON, clear it\r\n        this.clearSession();\r\n      }\r\n    }\r\n  }\r\n\r\n  login(credentials: LoginRequest): Observable<AuthResponse> {\r\n    return this.http\r\n      .post<AuthResponse>(`${this.apiUrl}/login`, credentials)\r\n      .pipe(tap((response) => this.setSession(response)));\r\n  }\r\n\r\n  register(data: RegisterRequest): Observable<AuthResponse> {\r\n    return this.http\r\n      .post<AuthResponse>(`${this.apiUrl}/register`, data)\r\n      .pipe(tap((response) => this.setSession(response)));\r\n  }\r\n\r\n  googleLogin(): void {\r\n    // Redirect to backend Google OAuth endpoint\r\n    window.location.href = `${this.apiUrl}/google`;\r\n  }\r\n\r\n  logout(): void {\r\n    const refreshToken = this.cookieService.get('refreshToken');\r\n    if (refreshToken) {\r\n      this.http.post(`${this.apiUrl}/logout`, { refreshToken }).subscribe();\r\n    }\r\n    this.clearSession();\r\n  }\r\n\r\n  refreshToken(): Observable<AuthResponse> {\r\n    const refreshToken = this.cookieService.get('refreshToken');\r\n    return this.http\r\n      .post<AuthResponse>(`${this.apiUrl}/refresh`, { refreshToken })\r\n      .pipe(tap((response) => this.setSession(response)));\r\n  }\r\n\r\n  isAuthenticated(): boolean {\r\n    const token = this.cookieService.get('accessToken');\r\n    return !!token && !this.isTokenExpired();\r\n  }\r\n\r\n  private setSession(authResult: AuthResponse): void {\r\n    // Store in cookies instead of localStorage\r\n    // Access token: 15 minutes (0.01 days  15 minutes)\r\n    this.cookieService.set('accessToken', authResult.accessToken, 0.01);\r\n    \r\n    // Refresh token: 7 days\r\n    this.cookieService.set('refreshToken', authResult.refreshToken, 7);\r\n    \r\n    // User data: 7 days (same as refresh token)\r\n    this.cookieService.set('user', JSON.stringify(authResult.user), 7);\r\n    \r\n    this.currentUserSubject.next(authResult.user);\r\n  }\r\n\r\n  private clearSession(): void {\r\n    // Delete cookies instead of localStorage\r\n    this.cookieService.delete('accessToken');\r\n    this.cookieService.delete('refreshToken');\r\n    this.cookieService.delete('user');\r\n    this.currentUserSubject.next(null);\r\n  }\r\n\r\n  private isTokenExpired(): boolean {\r\n    const token = this.cookieService.get('accessToken');\r\n    if (!token) return true;\r\n\r\n    try {\r\n      const expiry = JSON.parse(atob(token.split('.')[1])).exp;\r\n      return Math.floor(Date.now() / 1000) >= expiry;\r\n    } catch {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  getToken(): string | null {\r\n    return this.cookieService.get('accessToken');\r\n  }\r\n\r\n  // Get current user synchronously from cookies\r\n  getCurrentUser(): any | null {\r\n    const userStr = this.cookieService.get('user');\r\n    if (userStr) {\r\n      try {\r\n        return JSON.parse(userStr);\r\n      } catch {\r\n        return null;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Public method to set session from OAuth callback\r\n  setSessionFromCallback(authResult: AuthResponse): void {\r\n    this.setSession(authResult);\r\n  }\r\n\r\n  // Password reset methods\r\n  forgotPassword(email: string): Observable<any> {\r\n    return this.http.post(`${this.apiUrl}/forgot-password`, { email });\r\n  }\r\n\r\n  validateResetToken(token: string): Observable<any> {\r\n    console.log('Sending token to backend:', token);\r\n    console.log('Token length:', token?.length);\r\n    const requestBody = { token };\r\n    console.log('Request body:', requestBody);\r\n    console.log('API URL:', `${this.apiUrl}/validate-reset-token`);\r\n    \r\n    return this.http.post(`${this.apiUrl}/validate-reset-token`, requestBody).pipe(\r\n      tap(response => {\r\n        console.log('Raw HTTP response:', response);\r\n        console.log('Response type:', typeof response);\r\n      }),\r\n      catchError(error => {\r\n        console.error('HTTP error:', error);\r\n        console.error('Error status:', error.status);\r\n        console.error('Error message:', error.message);\r\n        console.error('Error body:', error.error);\r\n        throw error;\r\n      })\r\n    );\r\n  }\r\n\r\n  resetPassword(\r\n    token: string,\r\n    newPassword: string,\r\n    confirmPassword: string\r\n  ): Observable<any> {\r\n    const requestBody = {\r\n      token,\r\n      newPassword,\r\n      confirmPassword: confirmPassword, // Backend expects ConfirmPassword with capital C\r\n    };\r\n    \r\n    console.log('Reset password request:', {\r\n      token: token?.substring(0, 10) + '...',\r\n      newPassword: '***',\r\n      confirmPassword: '***',\r\n      passwordLength: newPassword?.length,\r\n      passwordsMatch: newPassword === confirmPassword\r\n    });\r\n    \r\n    return this.http.post(`${this.apiUrl}/reset-password`, requestBody);\r\n  }\r\n\r\n  // TOTP Methods\r\n  setupTotp(email: string): Observable<TotpSetupResponse> {\r\n    return this.http.post<TotpSetupResponse>(`${this.apiUrl}/setup-totp`, { email });\r\n  }\r\n\r\n  verifyTotp(email: string, code: string): Observable<AuthResponse> {\r\n    return this.http.post<AuthResponse>(`${this.apiUrl}/verify-totp`, { email, code });\r\n  }\r\n\r\n  sendEmailVerification(email: string): Observable<any> {\r\n    return this.http.post(`${this.apiUrl}/send-email-verification`, { email });\r\n  }\r\n\r\n  verifyEmail(email: string, code: string): Observable<any> {\r\n    return this.http.post(`${this.apiUrl}/verify-email`, { email, code });\r\n  }\r\n\r\n  setupTotpForExistingUser(email: string): Observable<TotpSetupResponse> {\r\n    return this.http.post<TotpSetupResponse>(`${this.apiUrl}/setup-totp-for-existing-user`, { email });\r\n  }\r\n\r\n  completeRegistration(email: string, code: string): Observable<AuthResponse> {\r\n    return this.http.post<AuthResponse>(`${this.apiUrl}/complete-registration`, { email, code });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\comments.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\cookie.service.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":35,"column":20,"nodeType":"MemberExpression","endLine":35,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@angular/core';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class CookieService {\r\n  /**\r\n   * Set a cookie\r\n   * @param name Cookie name\r\n   * @param value Cookie value\r\n   * @param days Expiration in days (default: 7)\r\n   */\r\n  set(name: string, value: string, days: number = 7): void {\r\n    const expires = new Date();\r\n    expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));\r\n    \r\n    // Set cookie with Secure and SameSite attributes\r\n    // Note: Secure requires HTTPS, so we'll set it conditionally\r\n    const isSecure = location.protocol === 'https:';\r\n    const secureFlag = isSecure ? '; Secure' : '';\r\n    \r\n    document.cookie = `${name}=${value}; expires=${expires.toUTCString()}; path=/; SameSite=Strict${secureFlag}`;\r\n  }\r\n\r\n  /**\r\n   * Get a cookie value\r\n   * @param name Cookie name\r\n   * @returns Cookie value or null\r\n   */\r\n  get(name: string): string | null {\r\n    const nameEQ = name + '=';\r\n    const cookies = document.cookie.split(';');\r\n    \r\n    for (let i = 0; i < cookies.length; i++) {\r\n      let cookie = cookies[i];\r\n      while (cookie.charAt(0) === ' ') {\r\n        cookie = cookie.substring(1, cookie.length);\r\n      }\r\n      if (cookie.indexOf(nameEQ) === 0) {\r\n        return cookie.substring(nameEQ.length, cookie.length);\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Delete a cookie\r\n   * @param name Cookie name\r\n   */\r\n  delete(name: string): void {\r\n    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;\r\n  }\r\n\r\n  /**\r\n   * Check if a cookie exists\r\n   * @param name Cookie name\r\n   * @returns True if cookie exists\r\n   */\r\n  has(name: string): boolean {\r\n    return this.get(name) !== null;\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\dashboard.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\follows.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[550,553],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[550,553],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[690,693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[690,693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1030,1033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1030,1033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1065,1068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1065,1068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1203,1206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1203,1206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1238,1241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1238,1241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { environment } from '../../environments/environment';\r\n\r\nexport interface FollowStatus {\r\n  isFollowing: boolean;\r\n}\r\n\r\nexport interface FollowCount {\r\n  count: number;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class FollowsService {\r\n  private apiUrl = `${environment.apiUrl}/follows`;\r\n\r\n  constructor(private http: HttpClient) {}\r\n\r\n  // Follow a user\r\n  followUser(userId: string): Observable<any> {\r\n    return this.http.post(`${this.apiUrl}/${userId}`, {});\r\n  }\r\n\r\n  // Unfollow a user\r\n  unfollowUser(userId: string): Observable<any> {\r\n    return this.http.delete(`${this.apiUrl}/${userId}`);\r\n  }\r\n\r\n  // Check if current user is following a user\r\n  getFollowStatus(userId: string): Observable<FollowStatus> {\r\n    return this.http.get<FollowStatus>(`${this.apiUrl}/${userId}/status`);\r\n  }\r\n\r\n  // Get followers of a user\r\n  getFollowers(userId: string): Observable<any[]> {\r\n    return this.http.get<any[]>(`${this.apiUrl}/${userId}/followers`);\r\n  }\r\n\r\n  // Get users that a user is following\r\n  getFollowing(userId: string): Observable<any[]> {\r\n    return this.http.get<any[]>(`${this.apiUrl}/${userId}/following`);\r\n  }\r\n\r\n  // Get follower count\r\n  getFollowerCount(userId: string): Observable<FollowCount> {\r\n    return this.http.get<FollowCount>(`${this.apiUrl}/${userId}/followers/count`);\r\n  }\r\n\r\n  // Get following count\r\n  getFollowingCount(userId: string): Observable<FollowCount> {\r\n    return this.http.get<FollowCount>(`${this.apiUrl}/${userId}/following/count`);\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\likes.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\posts.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\search.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\tags.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\toast.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Observable' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@angular/core';\r\nimport { BehaviorSubject, Observable } from 'rxjs';\r\n\r\nexport interface Toast {\r\n  id: string;\r\n  type: 'success' | 'error' | 'info' | 'warning';\r\n  title: string;\r\n  message: string;\r\n  duration?: number;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ToastService {\r\n  private toastsSubject = new BehaviorSubject<Toast[]>([]);\r\n  public toasts$ = this.toastsSubject.asObservable();\r\n\r\n  private showToast(toast: Omit<Toast, 'id'>): void {\r\n    const id = this.generateId();\r\n    const duration = toast.duration ?? 5000; // Use nullish coalescing to ensure it's always a number\r\n    const newToast: Toast = {\r\n      ...toast,\r\n      id,\r\n      duration\r\n    };\r\n\r\n    const currentToasts = this.toastsSubject.value;\r\n    this.toastsSubject.next([...currentToasts, newToast]);\r\n\r\n    // Auto remove toast after duration\r\n    if (duration > 0) {\r\n      setTimeout(() => {\r\n        this.removeToast(id);\r\n      }, duration);\r\n    }\r\n  }\r\n\r\n  success(title: string, message: string, duration?: number): void {\r\n    this.showToast({ type: 'success', title, message, duration });\r\n  }\r\n\r\n  error(title: string, message: string, duration?: number): void {\r\n    this.showToast({ type: 'error', title, message, duration });\r\n  }\r\n\r\n  info(title: string, message: string, duration?: number): void {\r\n    this.showToast({ type: 'info', title, message, duration });\r\n  }\r\n\r\n  warning(title: string, message: string, duration?: number): void {\r\n    this.showToast({ type: 'warning', title, message, duration });\r\n  }\r\n\r\n  removeToast(id: string): void {\r\n    const currentToasts = this.toastsSubject.value;\r\n    this.toastsSubject.next(currentToasts.filter(toast => toast.id !== id));\r\n  }\r\n\r\n  clearAll(): void {\r\n    this.toastsSubject.next([]);\r\n  }\r\n\r\n  private generateId(): string {\r\n    return Math.random().toString(36).substr(2, 9);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\user.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\services\\users.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[678,681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[678,681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[711,714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[711,714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { environment } from '../../environments/environment';\r\nimport { SuggestedUser } from '../interfaces';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class UsersService {\r\n  private apiUrl = `${environment.apiUrl}/users`;\r\n\r\n  constructor(private http: HttpClient) {}\r\n\r\n  // Get suggested users\r\n  getSuggestedUsers(count: number = 10): Observable<SuggestedUser[]> {\r\n    return this.http.get<SuggestedUser[]>(`${environment.apiUrl}/suggestedusers?count=${count}`);\r\n  }\r\n\r\n  // Get user by ID\r\n  getUserById(id: string): Observable<any> {\r\n    return this.http.get<any>(`${this.apiUrl}/${id}`);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\app\\utils\\role.util.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[166,169],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[166,169],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[926,929],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[926,929],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Utility function to normalize user role to string format\r\n * Handles both numeric enum values and string role names\r\n */\r\nexport function normalizeRole(role: any): string {\r\n  if (!role) {\r\n    return 'User';\r\n  }\r\n\r\n  // If it's already a string, return it\r\n  if (typeof role === 'string') {\r\n    return role;\r\n  }\r\n\r\n  // If it's a number, convert to string role name\r\n  if (typeof role === 'number') {\r\n    switch (role) {\r\n      case 0:\r\n        return 'User';\r\n      case 1:\r\n        return 'Admin';\r\n      case 2:\r\n        return 'Moderator';\r\n      case 3:\r\n        return 'Operation';\r\n      default:\r\n        return 'User';\r\n    }\r\n  }\r\n\r\n  // If it's a string representation of a number\r\n  if (typeof role === 'string' && !isNaN(Number(role))) {\r\n    return normalizeRole(Number(role));\r\n  }\r\n\r\n  return 'User';\r\n}\r\n\r\n/**\r\n * Check if a role matches the allowed roles\r\n */\r\nexport function hasRole(userRole: any, allowedRoles: string[]): boolean {\r\n  const normalizedRole = normalizeRole(userRole);\r\n  return allowedRoles.includes(normalizedRole);\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\environments\\environment.prod.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\environments\\environment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Jehad\\Documents\\GitHub\\EchoSpace\\src\\EchoSpace.Web.Client\\src\\main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]